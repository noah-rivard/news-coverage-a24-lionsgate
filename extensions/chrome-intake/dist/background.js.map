{
  "version": 3,
  "sources": ["../src/background.ts"],
  "sourcesContent": ["// Service worker: stores the latest scraped article and sends to ingest or processing API.\n\nconst DEFAULT_ENDPOINT = \"http://localhost:8000/process/articles\";\nconst CONTEXT_MENU_ID = \"capture-article\";\nconst CAPTURE_TIMEOUT_MS = 45000; // fail fast if a background tab hangs\nconst pendingBackgroundTabs = new Map<number, number>(); // tabId -> timeoutId\nlet sending = false;\n\ntype ArticlePayload = {\n  title: string;\n  source: string;\n  url: string;\n  published_at?: string;\n  content?: string;\n};\n\ntype StoredArticle = ArticlePayload & { scrapedAt: string };\ntype SendResult =\n  | { status: \"ok\"; duplicate_of?: string }\n  | { status: \"duplicate\"; duplicate_of: string }\n  | { status: \"error\"; error: string };\n\nfunction deriveQuarter(publishedAt?: string, scrapedAt?: string): string {\n  const source = publishedAt || scrapedAt;\n  if (source) {\n    const datePart = source.split(\"T\")[0];\n    const [yearStr, monthStr] = datePart.split(\"-\");\n    const year = Number(yearStr);\n    const month = Number(monthStr);\n    if (Number.isFinite(year) && Number.isFinite(month) && month >= 1 && month <= 12) {\n      const quarter = Math.floor((month - 1) / 3) + 1;\n      return `${year} Q${quarter}`;\n    }\n  }\n\n  const now = new Date();\n  const quarter = Math.floor(now.getMonth() / 3) + 1;\n  return `${now.getFullYear()} Q${quarter}`;\n}\n\nfunction resolvePublishedDate(publishedAt?: string, scrapedAt?: string): string | undefined {\n  if (publishedAt) {\n    return publishedAt;\n  }\n\n  if (scrapedAt) {\n    const datePart = scrapedAt.split(\"T\")[0];\n    if (datePart) {\n      return datePart;\n    }\n  }\n\n  return undefined;\n}\n\nfunction buildProcessPayload(article: StoredArticle) {\n  const publishDate = resolvePublishedDate(article.published_at, article.scrapedAt) ||\n    new Date().toISOString().slice(0, 10);\n  return {\n    title: article.title,\n    source: article.source || \"Unknown\",\n    url: article.url,\n    content: article.content || \"\",\n    published_at: publishDate,\n  };\n}\n\nfunction buildIngestPayload(article: StoredArticle) {\n  const publishDate = resolvePublishedDate(article.published_at, article.scrapedAt) ||\n    new Date().toISOString().slice(0, 10);\n  return {\n    company: \"Unknown\",\n    quarter: deriveQuarter(publishDate, article.scrapedAt),\n    title: article.title,\n    source: article.source || \"Unknown\",\n    url: article.url,\n    published_at: publishDate,\n    body: article.content || \"\",\n    ingest_source: \"chrome_extension\",\n    facts: [\n      {\n        fact_id: \"fact-1\",\n        category_path: \"Strategy & Miscellaneous News -> General News & Strategy\",\n        section: \"Strategy & Miscellaneous News\",\n        subheading: \"General News & Strategy\",\n        company: \"Unknown\",\n        quarter: deriveQuarter(publishDate, article.scrapedAt),\n        published_at: publishDate,\n        content_line: article.title,\n        summary_bullets: [article.title],\n      },\n    ],\n  };\n}\n\nasync function getEndpoint(): Promise<string> {\n  const { ingestEndpoint } = await chrome.storage.sync.get({\n    ingestEndpoint: DEFAULT_ENDPOINT,\n  });\n  return ingestEndpoint || DEFAULT_ENDPOINT;\n}\n\nasync function sendSingle(endpoint: string, body: Record<string, unknown>): Promise<SendResult> {\n  try {\n    const resp = await fetch(endpoint, {\n      method: \"POST\",\n      headers: { \"Content-Type\": \"application/json\" },\n      body: JSON.stringify(body),\n    });\n    const text = await resp.text();\n    let parsed: any = undefined;\n    try {\n      parsed = text ? JSON.parse(text) : undefined;\n    } catch {\n      /* ignore parse errors; fallback to raw text */\n    }\n    if (!resp.ok) {\n      const detail = parsed?.detail || text || resp.statusText;\n      return { status: \"error\", error: detail };\n    }\n    const duplicate_of = parsed?.duplicate_of;\n    if (duplicate_of) {\n      return { status: \"duplicate\", duplicate_of };\n    }\n    return { status: \"ok\", duplicate_of };\n  } catch (err: any) {\n    return { status: \"error\", error: err?.message || String(err) };\n  }\n}\n\nasync function enqueueArticle(article: StoredArticle) {\n  // Keep a single \"selected\" pending article aligned with what the popup shows.\n  // This prevents previously captured items from being resent when the user\n  // captures/sends a different article.\n  await chrome.storage.local.set({ latestArticle: article, pendingArticles: [article] });\n}\n\nasync function updatePendingArticles(pending: StoredArticle[]) {\n  await chrome.storage.local.set({ pendingArticles: pending });\n}\n\nfunction isSameStoredArticle(a: StoredArticle, b: StoredArticle): boolean {\n  return a.url === b.url && a.scrapedAt === b.scrapedAt;\n}\n\nasync function clearPendingIfSame(article: StoredArticle) {\n  const stored = await chrome.storage.local.get({ pendingArticles: [] as StoredArticle[] });\n  const pending = Array.isArray(stored.pendingArticles) ? stored.pendingArticles : [];\n  if (pending.length && isSameStoredArticle(pending[0], article)) {\n    await updatePendingArticles([]);\n  }\n}\n\nasync function sendProcessBatchSingle(endpoint: string, article: StoredArticle): Promise<SendResult> {\n  const body = [buildProcessPayload(article)];\n  try {\n    const resp = await fetch(endpoint, {\n      method: \"POST\",\n      headers: { \"Content-Type\": \"application/json\" },\n      body: JSON.stringify(body),\n    });\n    const text = await resp.text();\n    let parsed: any = undefined;\n    try {\n      parsed = text ? JSON.parse(text) : undefined;\n    } catch {\n      /* ignore parse errors; fallback to raw text */\n    }\n    if (!resp.ok) {\n      const detail = parsed?.detail || text || resp.statusText;\n      return { status: \"error\", error: detail };\n    }\n\n    const results = Array.isArray(parsed?.results) ? parsed.results : [];\n    if (!results.length) {\n      return { status: \"error\", error: \"Batch response missing per-article results.\" };\n    }\n\n    const item = results.find((r: any) => Number(r?.index) === 0) ?? results[0];\n    const status = item?.status;\n    if (status === \"processed\" || status === \"duplicate\") {\n      const duplicate_of = typeof item?.duplicate_of === \"string\" ? item.duplicate_of : undefined;\n      if (duplicate_of) {\n        return { status: \"duplicate\", duplicate_of };\n      }\n      return { status: \"ok\" };\n    }\n    if (status === \"invalid\") {\n      return { status: \"error\", error: item?.error || \"Article payload was invalid.\" };\n    }\n    return { status: \"error\", error: item?.error || \"Batch processing failed.\" };\n  } catch (err: any) {\n    return { status: \"error\", error: err?.message || String(err) };\n  }\n}\n\nasync function sendArticleOnce(article: StoredArticle): Promise<SendResult> {\n  const endpoint = await getEndpoint();\n  if (endpoint.includes(\"/ingest/\")) {\n    return sendSingle(endpoint, buildIngestPayload(article));\n  }\n  if (endpoint.includes(\"/process/articles\")) {\n    return sendProcessBatchSingle(endpoint, article);\n  }\n  return sendSingle(endpoint, buildProcessPayload(article));\n}\n\nasync function sendPendingLoop() {\n  while (true) {\n    const stored = await chrome.storage.local.get({ pendingArticles: [] as StoredArticle[] });\n    const pending = Array.isArray(stored.pendingArticles) ? stored.pendingArticles : [];\n    const article = pending[0];\n    if (!article) return;\n\n    const result = await sendArticleOnce(article);\n    await recordSendResult(result);\n    if (result.status === \"error\") return;\n\n    // Only clear if nothing newer replaced the pending slot while we were sending.\n    await clearPendingIfSame(article);\n  }\n}\n\nasync function sendLatestOnce(): Promise<SendResult> {\n  const stored = await chrome.storage.local.get({ latestArticle: null as StoredArticle | null });\n  if (!stored.latestArticle) {\n    return { status: \"error\", error: \"No article scraped yet.\" };\n  }\n  const result = await sendArticleOnce(stored.latestArticle);\n  await recordSendResult(result);\n  if (result.status !== \"error\") {\n    await clearPendingIfSame(stored.latestArticle);\n  }\n  return result;\n}\n\nasync function recordSendResult(result: SendResult) {\n  await chrome.storage.local.set({ lastSendStatus: result });\n  chrome.runtime.sendMessage({ type: \"SEND_RESULT\", ...result }).catch(() => undefined);\n}\n\nfunction toOriginPattern(rawUrl: string): string | null {\n  try {\n    const u = new URL(rawUrl);\n    if (u.protocol !== \"http:\" && u.protocol !== \"https:\") return null;\n    return `${u.protocol}//${u.host}/*`;\n  } catch {\n    return null;\n  }\n}\n\nfunction notifyCaptureFailure(reason: string) {\n  chrome.runtime.sendMessage({ type: \"CAPTURE_FAILED\", reason }).catch(() => {\n    /* no listeners; best-effort */\n  });\n}\n\nfunction ensureContextMenu() {\n  chrome.contextMenus.removeAll(() => {\n    chrome.contextMenus.create(\n      {\n        id: CONTEXT_MENU_ID,\n        title: \"Capture article for ingest\",\n        contexts: [\"page\", \"frame\", \"link\"],\n      },\n      () => {\n        const err = chrome.runtime.lastError;\n        if (err && !err.message.includes(\"duplicate id\")) {\n          console.warn(\"Failed to create context menu\", err.message);\n        }\n      }\n    );\n  });\n}\n\nensureContextMenu();\nchrome.runtime.onInstalled.addListener(ensureContextMenu);\nchrome.runtime.onStartup.addListener(ensureContextMenu);\n\nchrome.contextMenus.onClicked.addListener((info, tab) => {\n  if (info.menuItemId !== CONTEXT_MENU_ID || !tab?.id) {\n    return;\n  }\n\n  const frameUrl = info.frameUrl;\n  const targetUrl = info.linkUrl || frameUrl || info.pageUrl || tab.url;\n  if (!targetUrl) {\n    notifyCaptureFailure(\"No URL available to capture.\");\n    return;\n  }\n\n  const originPattern = toOriginPattern(targetUrl);\n  if (!originPattern) {\n    notifyCaptureFailure(\"Unsupported URL scheme.\");\n    return;\n  }\n\n  // Request must be synchronous on the user-gesture stack; no awaits before this.\n  chrome.permissions.request({ origins: [originPattern] }, (granted) => {\n    if (chrome.runtime.lastError) {\n      console.warn(\"permissions.request failed:\", chrome.runtime.lastError.message);\n      notifyCaptureFailure(chrome.runtime.lastError.message);\n      return;\n    }\n    if (!granted) {\n      notifyCaptureFailure(\"Site permission was denied.\");\n      return;\n    }\n\n    // Link capture -> background tab to avoid stealing focus.\n    if (info.linkUrl) {\n      captureInBackgroundTab(info.linkUrl);\n      return;\n    }\n\n    // Page/frame capture -> inject into the current tab/frame.\n    const frameId = typeof info.frameId === \"number\" ? info.frameId : undefined;\n    chrome.scripting.executeScript({\n      target: { tabId: tab.id!, frameIds: frameId !== undefined ? [frameId] : undefined },\n      files: [\"contentScript.js\"],\n    });\n  });\n});\n\nasync function captureInBackgroundTab(url: string) {\n  const tab = await chrome.tabs.create({ url, active: false });\n  const tabId = tab.id;\n  if (!tabId) return;\n\n  let listenerRef:\n    | ((updatedTabId: number, changeInfo: chrome.tabs.TabChangeInfo) => void)\n    | null = null;\n  let finished = false;\n  const finish = async (reason?: string) => {\n    if (finished) return;\n    finished = true;\n    if (reason) {\n      notifyCaptureFailure(reason);\n    }\n    const timeoutId = pendingBackgroundTabs.get(tabId);\n    if (timeoutId) clearTimeout(timeoutId);\n    pendingBackgroundTabs.delete(tabId);\n    if (listenerRef) {\n      chrome.tabs.onUpdated.removeListener(listenerRef);\n    }\n    chrome.tabs.remove(tabId).catch(() => undefined);\n  };\n\n  const timeout = setTimeout(() => {\n    finish(\n      `Capture timed out after ${Math.round(CAPTURE_TIMEOUT_MS / 1000)}s. Try capturing from the article page (not a link), or retry.`\n    );\n  }, CAPTURE_TIMEOUT_MS);\n  pendingBackgroundTabs.set(tabId, timeout);\n\n  // Wait briefly for load; MV3 does not allow synchronous tab load waits, so use onUpdated listener.\n  const injectAndClose = async () => {\n    try {\n      await chrome.scripting.executeScript({\n        target: { tabId },\n        files: [\"contentScript.js\"],\n      });\n      await finish();\n    } catch (err: any) {\n      await finish(err?.message ? `Capture failed: ${err.message}` : \"Capture failed.\");\n    }\n  };\n\n  const listener = async (\n    updatedTabId: number,\n    changeInfo: chrome.tabs.TabChangeInfo\n  ) => {\n    if (updatedTabId !== tabId || changeInfo.status !== \"complete\") return;\n    await injectAndClose();\n  };\n\n  listenerRef = listener;\n  chrome.tabs.onUpdated.addListener(listener);\n\n  // If the tab is already complete (rare but possible), inject immediately.\n  chrome.tabs.get(tabId).then((t) => {\n    if (t.status === \"complete\") {\n      injectAndClose();\n    }\n  });\n}\n\nchrome.runtime.onMessage.addListener((message, sender, sendResponse) => {\n  if (message?.type === \"ARTICLE_SCRAPED\") {\n    const article: StoredArticle = {\n      ...message.payload,\n      scrapedAt: new Date().toISOString(),\n    };\n    void (async () => {\n      await enqueueArticle(article);\n      if (sending) return;\n      sending = true;\n      try {\n        await sendPendingLoop();\n      } finally {\n        sending = false;\n      }\n    })();\n\n    // Close background capture tabs immediately on success.\n    const tabId = sender?.tab?.id;\n    if (typeof tabId === \"number\" && pendingBackgroundTabs.has(tabId)) {\n      const timeoutId = pendingBackgroundTabs.get(tabId);\n      if (timeoutId) clearTimeout(timeoutId);\n      pendingBackgroundTabs.delete(tabId);\n      chrome.tabs.remove(tabId).catch(() => undefined);\n    }\n    sendResponse({ status: \"stored\" });\n    return true;\n  }\n\n  if (message?.type === \"GET_LATEST_ARTICLE\") {\n    chrome.storage.local.get([\"latestArticle\", \"lastSendStatus\", \"pendingArticles\"]).then((data) => {\n      sendResponse({\n        article: data.latestArticle,\n        sendStatus: data.lastSendStatus,\n        pendingCount: Array.isArray(data.pendingArticles) ? data.pendingArticles.length : 0,\n      });\n    });\n    return true;\n  }\n\n  if (message?.type === \"SEND_TO_INGEST\") {\n    if (sending) {\n      sendResponse({ status: \"error\", error: \"Send already in progress.\" });\n      return true;\n    }\n    sending = true;\n    void (async () => {\n      try {\n        const result = await sendLatestOnce();\n        sendResponse(result);\n      } finally {\n        sending = false;\n      }\n    })();\n    return true;\n  }\n\n  return undefined;\n});\n"],
  "mappings": "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",
  "names": ["quarter"]
}
