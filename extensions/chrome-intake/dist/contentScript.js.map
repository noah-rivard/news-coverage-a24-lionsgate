{
  "version": 3,
  "sources": ["../node_modules/@mozilla/readability/Readability.js", "../node_modules/@mozilla/readability/Readability-readerable.js", "../node_modules/@mozilla/readability/index.js", "../src/contentScript.ts"],
  "sourcesContent": ["/*\n * Copyright (c) 2010 Arc90 Inc\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\n/*\n * This code is heavily based on Arc90's readability.js (1.7.1) script\n * available at: http://code.google.com/p/arc90labs-readability\n */\n\n/**\n * Public constructor.\n * @param {HTMLDocument} doc     The document to parse.\n * @param {Object}       options The options object.\n */\nfunction Readability(doc, options) {\n  // In some older versions, people passed a URI as the first argument. Cope:\n  if (options && options.documentElement) {\n    doc = options;\n    options = arguments[2];\n  } else if (!doc || !doc.documentElement) {\n    throw new Error(\"First argument to Readability constructor should be a document object.\");\n  }\n  options = options || {};\n\n  this._doc = doc;\n  this._docJSDOMParser = this._doc.firstChild.__JSDOMParser__;\n  this._articleTitle = null;\n  this._articleByline = null;\n  this._articleDir = null;\n  this._articleSiteName = null;\n  this._attempts = [];\n\n  // Configurable options\n  this._debug = !!options.debug;\n  this._maxElemsToParse = options.maxElemsToParse || this.DEFAULT_MAX_ELEMS_TO_PARSE;\n  this._nbTopCandidates = options.nbTopCandidates || this.DEFAULT_N_TOP_CANDIDATES;\n  this._charThreshold = options.charThreshold || this.DEFAULT_CHAR_THRESHOLD;\n  this._classesToPreserve = this.CLASSES_TO_PRESERVE.concat(options.classesToPreserve || []);\n  this._keepClasses = !!options.keepClasses;\n  this._serializer = options.serializer || function(el) {\n    return el.innerHTML;\n  };\n  this._disableJSONLD = !!options.disableJSONLD;\n  this._allowedVideoRegex = options.allowedVideoRegex || this.REGEXPS.videos;\n\n  // Start with all flags set\n  this._flags = this.FLAG_STRIP_UNLIKELYS |\n                this.FLAG_WEIGHT_CLASSES |\n                this.FLAG_CLEAN_CONDITIONALLY;\n\n\n  // Control whether log messages are sent to the console\n  if (this._debug) {\n    let logNode = function(node) {\n      if (node.nodeType == node.TEXT_NODE) {\n        return `${node.nodeName} (\"${node.textContent}\")`;\n      }\n      let attrPairs = Array.from(node.attributes || [], function(attr) {\n        return `${attr.name}=\"${attr.value}\"`;\n      }).join(\" \");\n      return `<${node.localName} ${attrPairs}>`;\n    };\n    this.log = function () {\n      if (typeof console !== \"undefined\") {\n        let args = Array.from(arguments, arg => {\n          if (arg && arg.nodeType == this.ELEMENT_NODE) {\n            return logNode(arg);\n          }\n          return arg;\n        });\n        args.unshift(\"Reader: (Readability)\");\n        console.log.apply(console, args);\n      } else if (typeof dump !== \"undefined\") {\n        /* global dump */\n        var msg = Array.prototype.map.call(arguments, function(x) {\n          return (x && x.nodeName) ? logNode(x) : x;\n        }).join(\" \");\n        dump(\"Reader: (Readability) \" + msg + \"\\n\");\n      }\n    };\n  } else {\n    this.log = function () {};\n  }\n}\n\nReadability.prototype = {\n  FLAG_STRIP_UNLIKELYS: 0x1,\n  FLAG_WEIGHT_CLASSES: 0x2,\n  FLAG_CLEAN_CONDITIONALLY: 0x4,\n\n  // https://developer.mozilla.org/en-US/docs/Web/API/Node/nodeType\n  ELEMENT_NODE: 1,\n  TEXT_NODE: 3,\n\n  // Max number of nodes supported by this parser. Default: 0 (no limit)\n  DEFAULT_MAX_ELEMS_TO_PARSE: 0,\n\n  // The number of top candidates to consider when analysing how\n  // tight the competition is among candidates.\n  DEFAULT_N_TOP_CANDIDATES: 5,\n\n  // Element tags to score by default.\n  DEFAULT_TAGS_TO_SCORE: \"section,h2,h3,h4,h5,h6,p,td,pre\".toUpperCase().split(\",\"),\n\n  // The default number of chars an article must have in order to return a result\n  DEFAULT_CHAR_THRESHOLD: 500,\n\n  // All of the regular expressions in use within readability.\n  // Defined up here so we don't instantiate them repeatedly in loops.\n  REGEXPS: {\n    // NOTE: These two regular expressions are duplicated in\n    // Readability-readerable.js. Please keep both copies in sync.\n    unlikelyCandidates: /-ad-|ai2html|banner|breadcrumbs|combx|comment|community|cover-wrap|disqus|extra|footer|gdpr|header|legends|menu|related|remark|replies|rss|shoutbox|sidebar|skyscraper|social|sponsor|supplemental|ad-break|agegate|pagination|pager|popup|yom-remote/i,\n    okMaybeItsACandidate: /and|article|body|column|content|main|shadow/i,\n\n    positive: /article|body|content|entry|hentry|h-entry|main|page|pagination|post|text|blog|story/i,\n    negative: /-ad-|hidden|^hid$| hid$| hid |^hid |banner|combx|comment|com-|contact|foot|footer|footnote|gdpr|masthead|media|meta|outbrain|promo|related|scroll|share|shoutbox|sidebar|skyscraper|sponsor|shopping|tags|tool|widget/i,\n    extraneous: /print|archive|comment|discuss|e[\\-]?mail|share|reply|all|login|sign|single|utility/i,\n    byline: /byline|author|dateline|writtenby|p-author/i,\n    replaceFonts: /<(\\/?)font[^>]*>/gi,\n    normalize: /\\s{2,}/g,\n    videos: /\\/\\/(www\\.)?((dailymotion|youtube|youtube-nocookie|player\\.vimeo|v\\.qq)\\.com|(archive|upload\\.wikimedia)\\.org|player\\.twitch\\.tv)/i,\n    shareElements: /(\\b|_)(share|sharedaddy)(\\b|_)/i,\n    nextLink: /(next|weiter|continue|>([^\\|]|$)|\u00BB([^\\|]|$))/i,\n    prevLink: /(prev|earl|old|new|<|\u00AB)/i,\n    tokenize: /\\W+/g,\n    whitespace: /^\\s*$/,\n    hasContent: /\\S$/,\n    hashUrl: /^#.+/,\n    srcsetUrl: /(\\S+)(\\s+[\\d.]+[xw])?(\\s*(?:,|$))/g,\n    b64DataUrl: /^data:\\s*([^\\s;,]+)\\s*;\\s*base64\\s*,/i,\n    // Commas as used in Latin, Sindhi, Chinese and various other scripts.\n    // see: https://en.wikipedia.org/wiki/Comma#Comma_variants\n    commas: /\\u002C|\\u060C|\\uFE50|\\uFE10|\\uFE11|\\u2E41|\\u2E34|\\u2E32|\\uFF0C/g,\n    // See: https://schema.org/Article\n    jsonLdArticleTypes: /^Article|AdvertiserContentArticle|NewsArticle|AnalysisNewsArticle|AskPublicNewsArticle|BackgroundNewsArticle|OpinionNewsArticle|ReportageNewsArticle|ReviewNewsArticle|Report|SatiricalArticle|ScholarlyArticle|MedicalScholarlyArticle|SocialMediaPosting|BlogPosting|LiveBlogPosting|DiscussionForumPosting|TechArticle|APIReference$/\n  },\n\n  UNLIKELY_ROLES: [ \"menu\", \"menubar\", \"complementary\", \"navigation\", \"alert\", \"alertdialog\", \"dialog\" ],\n\n  DIV_TO_P_ELEMS: new Set([ \"BLOCKQUOTE\", \"DL\", \"DIV\", \"IMG\", \"OL\", \"P\", \"PRE\", \"TABLE\", \"UL\" ]),\n\n  ALTER_TO_DIV_EXCEPTIONS: [\"DIV\", \"ARTICLE\", \"SECTION\", \"P\"],\n\n  PRESENTATIONAL_ATTRIBUTES: [ \"align\", \"background\", \"bgcolor\", \"border\", \"cellpadding\", \"cellspacing\", \"frame\", \"hspace\", \"rules\", \"style\", \"valign\", \"vspace\" ],\n\n  DEPRECATED_SIZE_ATTRIBUTE_ELEMS: [ \"TABLE\", \"TH\", \"TD\", \"HR\", \"PRE\" ],\n\n  // The commented out elements qualify as phrasing content but tend to be\n  // removed by readability when put into paragraphs, so we ignore them here.\n  PHRASING_ELEMS: [\n    // \"CANVAS\", \"IFRAME\", \"SVG\", \"VIDEO\",\n    \"ABBR\", \"AUDIO\", \"B\", \"BDO\", \"BR\", \"BUTTON\", \"CITE\", \"CODE\", \"DATA\",\n    \"DATALIST\", \"DFN\", \"EM\", \"EMBED\", \"I\", \"IMG\", \"INPUT\", \"KBD\", \"LABEL\",\n    \"MARK\", \"MATH\", \"METER\", \"NOSCRIPT\", \"OBJECT\", \"OUTPUT\", \"PROGRESS\", \"Q\",\n    \"RUBY\", \"SAMP\", \"SCRIPT\", \"SELECT\", \"SMALL\", \"SPAN\", \"STRONG\", \"SUB\",\n    \"SUP\", \"TEXTAREA\", \"TIME\", \"VAR\", \"WBR\"\n  ],\n\n  // These are the classes that readability sets itself.\n  CLASSES_TO_PRESERVE: [ \"page\" ],\n\n  // These are the list of HTML entities that need to be escaped.\n  HTML_ESCAPE_MAP: {\n    \"lt\": \"<\",\n    \"gt\": \">\",\n    \"amp\": \"&\",\n    \"quot\": '\"',\n    \"apos\": \"'\",\n  },\n\n  /**\n   * Run any post-process modifications to article content as necessary.\n   *\n   * @param Element\n   * @return void\n  **/\n  _postProcessContent: function(articleContent) {\n    // Readability cannot open relative uris so we convert them to absolute uris.\n    this._fixRelativeUris(articleContent);\n\n    this._simplifyNestedElements(articleContent);\n\n    if (!this._keepClasses) {\n      // Remove classes.\n      this._cleanClasses(articleContent);\n    }\n  },\n\n  /**\n   * Iterates over a NodeList, calls `filterFn` for each node and removes node\n   * if function returned `true`.\n   *\n   * If function is not passed, removes all the nodes in node list.\n   *\n   * @param NodeList nodeList The nodes to operate on\n   * @param Function filterFn the function to use as a filter\n   * @return void\n   */\n  _removeNodes: function(nodeList, filterFn) {\n    // Avoid ever operating on live node lists.\n    if (this._docJSDOMParser && nodeList._isLiveNodeList) {\n      throw new Error(\"Do not pass live node lists to _removeNodes\");\n    }\n    for (var i = nodeList.length - 1; i >= 0; i--) {\n      var node = nodeList[i];\n      var parentNode = node.parentNode;\n      if (parentNode) {\n        if (!filterFn || filterFn.call(this, node, i, nodeList)) {\n          parentNode.removeChild(node);\n        }\n      }\n    }\n  },\n\n  /**\n   * Iterates over a NodeList, and calls _setNodeTag for each node.\n   *\n   * @param NodeList nodeList The nodes to operate on\n   * @param String newTagName the new tag name to use\n   * @return void\n   */\n  _replaceNodeTags: function(nodeList, newTagName) {\n    // Avoid ever operating on live node lists.\n    if (this._docJSDOMParser && nodeList._isLiveNodeList) {\n      throw new Error(\"Do not pass live node lists to _replaceNodeTags\");\n    }\n    for (const node of nodeList) {\n      this._setNodeTag(node, newTagName);\n    }\n  },\n\n  /**\n   * Iterate over a NodeList, which doesn't natively fully implement the Array\n   * interface.\n   *\n   * For convenience, the current object context is applied to the provided\n   * iterate function.\n   *\n   * @param  NodeList nodeList The NodeList.\n   * @param  Function fn       The iterate function.\n   * @return void\n   */\n  _forEachNode: function(nodeList, fn) {\n    Array.prototype.forEach.call(nodeList, fn, this);\n  },\n\n  /**\n   * Iterate over a NodeList, and return the first node that passes\n   * the supplied test function\n   *\n   * For convenience, the current object context is applied to the provided\n   * test function.\n   *\n   * @param  NodeList nodeList The NodeList.\n   * @param  Function fn       The test function.\n   * @return void\n   */\n  _findNode: function(nodeList, fn) {\n    return Array.prototype.find.call(nodeList, fn, this);\n  },\n\n  /**\n   * Iterate over a NodeList, return true if any of the provided iterate\n   * function calls returns true, false otherwise.\n   *\n   * For convenience, the current object context is applied to the\n   * provided iterate function.\n   *\n   * @param  NodeList nodeList The NodeList.\n   * @param  Function fn       The iterate function.\n   * @return Boolean\n   */\n  _someNode: function(nodeList, fn) {\n    return Array.prototype.some.call(nodeList, fn, this);\n  },\n\n  /**\n   * Iterate over a NodeList, return true if all of the provided iterate\n   * function calls return true, false otherwise.\n   *\n   * For convenience, the current object context is applied to the\n   * provided iterate function.\n   *\n   * @param  NodeList nodeList The NodeList.\n   * @param  Function fn       The iterate function.\n   * @return Boolean\n   */\n  _everyNode: function(nodeList, fn) {\n    return Array.prototype.every.call(nodeList, fn, this);\n  },\n\n  /**\n   * Concat all nodelists passed as arguments.\n   *\n   * @return ...NodeList\n   * @return Array\n   */\n  _concatNodeLists: function() {\n    var slice = Array.prototype.slice;\n    var args = slice.call(arguments);\n    var nodeLists = args.map(function(list) {\n      return slice.call(list);\n    });\n    return Array.prototype.concat.apply([], nodeLists);\n  },\n\n  _getAllNodesWithTag: function(node, tagNames) {\n    if (node.querySelectorAll) {\n      return node.querySelectorAll(tagNames.join(\",\"));\n    }\n    return [].concat.apply([], tagNames.map(function(tag) {\n      var collection = node.getElementsByTagName(tag);\n      return Array.isArray(collection) ? collection : Array.from(collection);\n    }));\n  },\n\n  /**\n   * Removes the class=\"\" attribute from every element in the given\n   * subtree, except those that match CLASSES_TO_PRESERVE and\n   * the classesToPreserve array from the options object.\n   *\n   * @param Element\n   * @return void\n   */\n  _cleanClasses: function(node) {\n    var classesToPreserve = this._classesToPreserve;\n    var className = (node.getAttribute(\"class\") || \"\")\n      .split(/\\s+/)\n      .filter(function(cls) {\n        return classesToPreserve.indexOf(cls) != -1;\n      })\n      .join(\" \");\n\n    if (className) {\n      node.setAttribute(\"class\", className);\n    } else {\n      node.removeAttribute(\"class\");\n    }\n\n    for (node = node.firstElementChild; node; node = node.nextElementSibling) {\n      this._cleanClasses(node);\n    }\n  },\n\n  /**\n   * Converts each <a> and <img> uri in the given element to an absolute URI,\n   * ignoring #ref URIs.\n   *\n   * @param Element\n   * @return void\n   */\n  _fixRelativeUris: function(articleContent) {\n    var baseURI = this._doc.baseURI;\n    var documentURI = this._doc.documentURI;\n    function toAbsoluteURI(uri) {\n      // Leave hash links alone if the base URI matches the document URI:\n      if (baseURI == documentURI && uri.charAt(0) == \"#\") {\n        return uri;\n      }\n\n      // Otherwise, resolve against base URI:\n      try {\n        return new URL(uri, baseURI).href;\n      } catch (ex) {\n        // Something went wrong, just return the original:\n      }\n      return uri;\n    }\n\n    var links = this._getAllNodesWithTag(articleContent, [\"a\"]);\n    this._forEachNode(links, function(link) {\n      var href = link.getAttribute(\"href\");\n      if (href) {\n        // Remove links with javascript: URIs, since\n        // they won't work after scripts have been removed from the page.\n        if (href.indexOf(\"javascript:\") === 0) {\n          // if the link only contains simple text content, it can be converted to a text node\n          if (link.childNodes.length === 1 && link.childNodes[0].nodeType === this.TEXT_NODE) {\n            var text = this._doc.createTextNode(link.textContent);\n            link.parentNode.replaceChild(text, link);\n          } else {\n            // if the link has multiple children, they should all be preserved\n            var container = this._doc.createElement(\"span\");\n            while (link.firstChild) {\n              container.appendChild(link.firstChild);\n            }\n            link.parentNode.replaceChild(container, link);\n          }\n        } else {\n          link.setAttribute(\"href\", toAbsoluteURI(href));\n        }\n      }\n    });\n\n    var medias = this._getAllNodesWithTag(articleContent, [\n      \"img\", \"picture\", \"figure\", \"video\", \"audio\", \"source\"\n    ]);\n\n    this._forEachNode(medias, function(media) {\n      var src = media.getAttribute(\"src\");\n      var poster = media.getAttribute(\"poster\");\n      var srcset = media.getAttribute(\"srcset\");\n\n      if (src) {\n        media.setAttribute(\"src\", toAbsoluteURI(src));\n      }\n\n      if (poster) {\n        media.setAttribute(\"poster\", toAbsoluteURI(poster));\n      }\n\n      if (srcset) {\n        var newSrcset = srcset.replace(this.REGEXPS.srcsetUrl, function(_, p1, p2, p3) {\n          return toAbsoluteURI(p1) + (p2 || \"\") + p3;\n        });\n\n        media.setAttribute(\"srcset\", newSrcset);\n      }\n    });\n  },\n\n  _simplifyNestedElements: function(articleContent) {\n    var node = articleContent;\n\n    while (node) {\n      if (node.parentNode && [\"DIV\", \"SECTION\"].includes(node.tagName) && !(node.id && node.id.startsWith(\"readability\"))) {\n        if (this._isElementWithoutContent(node)) {\n          node = this._removeAndGetNext(node);\n          continue;\n        } else if (this._hasSingleTagInsideElement(node, \"DIV\") || this._hasSingleTagInsideElement(node, \"SECTION\")) {\n          var child = node.children[0];\n          for (var i = 0; i < node.attributes.length; i++) {\n            child.setAttribute(node.attributes[i].name, node.attributes[i].value);\n          }\n          node.parentNode.replaceChild(child, node);\n          node = child;\n          continue;\n        }\n      }\n\n      node = this._getNextNode(node);\n    }\n  },\n\n  /**\n   * Get the article title as an H1.\n   *\n   * @return string\n   **/\n  _getArticleTitle: function() {\n    var doc = this._doc;\n    var curTitle = \"\";\n    var origTitle = \"\";\n\n    try {\n      curTitle = origTitle = doc.title.trim();\n\n      // If they had an element with id \"title\" in their HTML\n      if (typeof curTitle !== \"string\")\n        curTitle = origTitle = this._getInnerText(doc.getElementsByTagName(\"title\")[0]);\n    } catch (e) {/* ignore exceptions setting the title. */}\n\n    var titleHadHierarchicalSeparators = false;\n    function wordCount(str) {\n      return str.split(/\\s+/).length;\n    }\n\n    // If there's a separator in the title, first remove the final part\n    if ((/ [\\|\\-\\\\\\/>\u00BB] /).test(curTitle)) {\n      titleHadHierarchicalSeparators = / [\\\\\\/>\u00BB] /.test(curTitle);\n      curTitle = origTitle.replace(/(.*)[\\|\\-\\\\\\/>\u00BB] .*/gi, \"$1\");\n\n      // If the resulting title is too short (3 words or fewer), remove\n      // the first part instead:\n      if (wordCount(curTitle) < 3)\n        curTitle = origTitle.replace(/[^\\|\\-\\\\\\/>\u00BB]*[\\|\\-\\\\\\/>\u00BB](.*)/gi, \"$1\");\n    } else if (curTitle.indexOf(\": \") !== -1) {\n      // Check if we have an heading containing this exact string, so we\n      // could assume it's the full title.\n      var headings = this._concatNodeLists(\n        doc.getElementsByTagName(\"h1\"),\n        doc.getElementsByTagName(\"h2\")\n      );\n      var trimmedTitle = curTitle.trim();\n      var match = this._someNode(headings, function(heading) {\n        return heading.textContent.trim() === trimmedTitle;\n      });\n\n      // If we don't, let's extract the title out of the original title string.\n      if (!match) {\n        curTitle = origTitle.substring(origTitle.lastIndexOf(\":\") + 1);\n\n        // If the title is now too short, try the first colon instead:\n        if (wordCount(curTitle) < 3) {\n          curTitle = origTitle.substring(origTitle.indexOf(\":\") + 1);\n          // But if we have too many words before the colon there's something weird\n          // with the titles and the H tags so let's just use the original title instead\n        } else if (wordCount(origTitle.substr(0, origTitle.indexOf(\":\"))) > 5) {\n          curTitle = origTitle;\n        }\n      }\n    } else if (curTitle.length > 150 || curTitle.length < 15) {\n      var hOnes = doc.getElementsByTagName(\"h1\");\n\n      if (hOnes.length === 1)\n        curTitle = this._getInnerText(hOnes[0]);\n    }\n\n    curTitle = curTitle.trim().replace(this.REGEXPS.normalize, \" \");\n    // If we now have 4 words or fewer as our title, and either no\n    // 'hierarchical' separators (\\, /, > or \u00BB) were found in the original\n    // title or we decreased the number of words by more than 1 word, use\n    // the original title.\n    var curTitleWordCount = wordCount(curTitle);\n    if (curTitleWordCount <= 4 &&\n        (!titleHadHierarchicalSeparators ||\n         curTitleWordCount != wordCount(origTitle.replace(/[\\|\\-\\\\\\/>\u00BB]+/g, \"\")) - 1)) {\n      curTitle = origTitle;\n    }\n\n    return curTitle;\n  },\n\n  /**\n   * Prepare the HTML document for readability to scrape it.\n   * This includes things like stripping javascript, CSS, and handling terrible markup.\n   *\n   * @return void\n   **/\n  _prepDocument: function() {\n    var doc = this._doc;\n\n    // Remove all style tags in head\n    this._removeNodes(this._getAllNodesWithTag(doc, [\"style\"]));\n\n    if (doc.body) {\n      this._replaceBrs(doc.body);\n    }\n\n    this._replaceNodeTags(this._getAllNodesWithTag(doc, [\"font\"]), \"SPAN\");\n  },\n\n  /**\n   * Finds the next node, starting from the given node, and ignoring\n   * whitespace in between. If the given node is an element, the same node is\n   * returned.\n   */\n  _nextNode: function (node) {\n    var next = node;\n    while (next\n        && (next.nodeType != this.ELEMENT_NODE)\n        && this.REGEXPS.whitespace.test(next.textContent)) {\n      next = next.nextSibling;\n    }\n    return next;\n  },\n\n  /**\n   * Replaces 2 or more successive <br> elements with a single <p>.\n   * Whitespace between <br> elements are ignored. For example:\n   *   <div>foo<br>bar<br> <br><br>abc</div>\n   * will become:\n   *   <div>foo<br>bar<p>abc</p></div>\n   */\n  _replaceBrs: function (elem) {\n    this._forEachNode(this._getAllNodesWithTag(elem, [\"br\"]), function(br) {\n      var next = br.nextSibling;\n\n      // Whether 2 or more <br> elements have been found and replaced with a\n      // <p> block.\n      var replaced = false;\n\n      // If we find a <br> chain, remove the <br>s until we hit another node\n      // or non-whitespace. This leaves behind the first <br> in the chain\n      // (which will be replaced with a <p> later).\n      while ((next = this._nextNode(next)) && (next.tagName == \"BR\")) {\n        replaced = true;\n        var brSibling = next.nextSibling;\n        next.parentNode.removeChild(next);\n        next = brSibling;\n      }\n\n      // If we removed a <br> chain, replace the remaining <br> with a <p>. Add\n      // all sibling nodes as children of the <p> until we hit another <br>\n      // chain.\n      if (replaced) {\n        var p = this._doc.createElement(\"p\");\n        br.parentNode.replaceChild(p, br);\n\n        next = p.nextSibling;\n        while (next) {\n          // If we've hit another <br><br>, we're done adding children to this <p>.\n          if (next.tagName == \"BR\") {\n            var nextElem = this._nextNode(next.nextSibling);\n            if (nextElem && nextElem.tagName == \"BR\")\n              break;\n          }\n\n          if (!this._isPhrasingContent(next))\n            break;\n\n          // Otherwise, make this node a child of the new <p>.\n          var sibling = next.nextSibling;\n          p.appendChild(next);\n          next = sibling;\n        }\n\n        while (p.lastChild && this._isWhitespace(p.lastChild)) {\n          p.removeChild(p.lastChild);\n        }\n\n        if (p.parentNode.tagName === \"P\")\n          this._setNodeTag(p.parentNode, \"DIV\");\n      }\n    });\n  },\n\n  _setNodeTag: function (node, tag) {\n    this.log(\"_setNodeTag\", node, tag);\n    if (this._docJSDOMParser) {\n      node.localName = tag.toLowerCase();\n      node.tagName = tag.toUpperCase();\n      return node;\n    }\n\n    var replacement = node.ownerDocument.createElement(tag);\n    while (node.firstChild) {\n      replacement.appendChild(node.firstChild);\n    }\n    node.parentNode.replaceChild(replacement, node);\n    if (node.readability)\n      replacement.readability = node.readability;\n\n    for (var i = 0; i < node.attributes.length; i++) {\n      try {\n        replacement.setAttribute(node.attributes[i].name, node.attributes[i].value);\n      } catch (ex) {\n        /* it's possible for setAttribute() to throw if the attribute name\n         * isn't a valid XML Name. Such attributes can however be parsed from\n         * source in HTML docs, see https://github.com/whatwg/html/issues/4275,\n         * so we can hit them here and then throw. We don't care about such\n         * attributes so we ignore them.\n         */\n      }\n    }\n    return replacement;\n  },\n\n  /**\n   * Prepare the article node for display. Clean out any inline styles,\n   * iframes, forms, strip extraneous <p> tags, etc.\n   *\n   * @param Element\n   * @return void\n   **/\n  _prepArticle: function(articleContent) {\n    this._cleanStyles(articleContent);\n\n    // Check for data tables before we continue, to avoid removing items in\n    // those tables, which will often be isolated even though they're\n    // visually linked to other content-ful elements (text, images, etc.).\n    this._markDataTables(articleContent);\n\n    this._fixLazyImages(articleContent);\n\n    // Clean out junk from the article content\n    this._cleanConditionally(articleContent, \"form\");\n    this._cleanConditionally(articleContent, \"fieldset\");\n    this._clean(articleContent, \"object\");\n    this._clean(articleContent, \"embed\");\n    this._clean(articleContent, \"footer\");\n    this._clean(articleContent, \"link\");\n    this._clean(articleContent, \"aside\");\n\n    // Clean out elements with little content that have \"share\" in their id/class combinations from final top candidates,\n    // which means we don't remove the top candidates even they have \"share\".\n\n    var shareElementThreshold = this.DEFAULT_CHAR_THRESHOLD;\n\n    this._forEachNode(articleContent.children, function (topCandidate) {\n      this._cleanMatchedNodes(topCandidate, function (node, matchString) {\n        return this.REGEXPS.shareElements.test(matchString) && node.textContent.length < shareElementThreshold;\n      });\n    });\n\n    this._clean(articleContent, \"iframe\");\n    this._clean(articleContent, \"input\");\n    this._clean(articleContent, \"textarea\");\n    this._clean(articleContent, \"select\");\n    this._clean(articleContent, \"button\");\n    this._cleanHeaders(articleContent);\n\n    // Do these last as the previous stuff may have removed junk\n    // that will affect these\n    this._cleanConditionally(articleContent, \"table\");\n    this._cleanConditionally(articleContent, \"ul\");\n    this._cleanConditionally(articleContent, \"div\");\n\n    // replace H1 with H2 as H1 should be only title that is displayed separately\n    this._replaceNodeTags(this._getAllNodesWithTag(articleContent, [\"h1\"]), \"h2\");\n\n    // Remove extra paragraphs\n    this._removeNodes(this._getAllNodesWithTag(articleContent, [\"p\"]), function (paragraph) {\n      var imgCount = paragraph.getElementsByTagName(\"img\").length;\n      var embedCount = paragraph.getElementsByTagName(\"embed\").length;\n      var objectCount = paragraph.getElementsByTagName(\"object\").length;\n      // At this point, nasty iframes have been removed, only remain embedded video ones.\n      var iframeCount = paragraph.getElementsByTagName(\"iframe\").length;\n      var totalCount = imgCount + embedCount + objectCount + iframeCount;\n\n      return totalCount === 0 && !this._getInnerText(paragraph, false);\n    });\n\n    this._forEachNode(this._getAllNodesWithTag(articleContent, [\"br\"]), function(br) {\n      var next = this._nextNode(br.nextSibling);\n      if (next && next.tagName == \"P\")\n        br.parentNode.removeChild(br);\n    });\n\n    // Remove single-cell tables\n    this._forEachNode(this._getAllNodesWithTag(articleContent, [\"table\"]), function(table) {\n      var tbody = this._hasSingleTagInsideElement(table, \"TBODY\") ? table.firstElementChild : table;\n      if (this._hasSingleTagInsideElement(tbody, \"TR\")) {\n        var row = tbody.firstElementChild;\n        if (this._hasSingleTagInsideElement(row, \"TD\")) {\n          var cell = row.firstElementChild;\n          cell = this._setNodeTag(cell, this._everyNode(cell.childNodes, this._isPhrasingContent) ? \"P\" : \"DIV\");\n          table.parentNode.replaceChild(cell, table);\n        }\n      }\n    });\n  },\n\n  /**\n   * Initialize a node with the readability object. Also checks the\n   * className/id for special names to add to its score.\n   *\n   * @param Element\n   * @return void\n  **/\n  _initializeNode: function(node) {\n    node.readability = {\"contentScore\": 0};\n\n    switch (node.tagName) {\n      case \"DIV\":\n        node.readability.contentScore += 5;\n        break;\n\n      case \"PRE\":\n      case \"TD\":\n      case \"BLOCKQUOTE\":\n        node.readability.contentScore += 3;\n        break;\n\n      case \"ADDRESS\":\n      case \"OL\":\n      case \"UL\":\n      case \"DL\":\n      case \"DD\":\n      case \"DT\":\n      case \"LI\":\n      case \"FORM\":\n        node.readability.contentScore -= 3;\n        break;\n\n      case \"H1\":\n      case \"H2\":\n      case \"H3\":\n      case \"H4\":\n      case \"H5\":\n      case \"H6\":\n      case \"TH\":\n        node.readability.contentScore -= 5;\n        break;\n    }\n\n    node.readability.contentScore += this._getClassWeight(node);\n  },\n\n  _removeAndGetNext: function(node) {\n    var nextNode = this._getNextNode(node, true);\n    node.parentNode.removeChild(node);\n    return nextNode;\n  },\n\n  /**\n   * Traverse the DOM from node to node, starting at the node passed in.\n   * Pass true for the second parameter to indicate this node itself\n   * (and its kids) are going away, and we want the next node over.\n   *\n   * Calling this in a loop will traverse the DOM depth-first.\n   */\n  _getNextNode: function(node, ignoreSelfAndKids) {\n    // First check for kids if those aren't being ignored\n    if (!ignoreSelfAndKids && node.firstElementChild) {\n      return node.firstElementChild;\n    }\n    // Then for siblings...\n    if (node.nextElementSibling) {\n      return node.nextElementSibling;\n    }\n    // And finally, move up the parent chain *and* find a sibling\n    // (because this is depth-first traversal, we will have already\n    // seen the parent nodes themselves).\n    do {\n      node = node.parentNode;\n    } while (node && !node.nextElementSibling);\n    return node && node.nextElementSibling;\n  },\n\n  // compares second text to first one\n  // 1 = same text, 0 = completely different text\n  // works the way that it splits both texts into words and then finds words that are unique in second text\n  // the result is given by the lower length of unique parts\n  _textSimilarity: function(textA, textB) {\n    var tokensA = textA.toLowerCase().split(this.REGEXPS.tokenize).filter(Boolean);\n    var tokensB = textB.toLowerCase().split(this.REGEXPS.tokenize).filter(Boolean);\n    if (!tokensA.length || !tokensB.length) {\n      return 0;\n    }\n    var uniqTokensB = tokensB.filter(token => !tokensA.includes(token));\n    var distanceB = uniqTokensB.join(\" \").length / tokensB.join(\" \").length;\n    return 1 - distanceB;\n  },\n\n  _checkByline: function(node, matchString) {\n    if (this._articleByline) {\n      return false;\n    }\n\n    if (node.getAttribute !== undefined) {\n      var rel = node.getAttribute(\"rel\");\n      var itemprop = node.getAttribute(\"itemprop\");\n    }\n\n    if ((rel === \"author\" || (itemprop && itemprop.indexOf(\"author\") !== -1) || this.REGEXPS.byline.test(matchString)) && this._isValidByline(node.textContent)) {\n      this._articleByline = node.textContent.trim();\n      return true;\n    }\n\n    return false;\n  },\n\n  _getNodeAncestors: function(node, maxDepth) {\n    maxDepth = maxDepth || 0;\n    var i = 0, ancestors = [];\n    while (node.parentNode) {\n      ancestors.push(node.parentNode);\n      if (maxDepth && ++i === maxDepth)\n        break;\n      node = node.parentNode;\n    }\n    return ancestors;\n  },\n\n  /***\n   * grabArticle - Using a variety of metrics (content score, classname, element types), find the content that is\n   *         most likely to be the stuff a user wants to read. Then return it wrapped up in a div.\n   *\n   * @param page a document to run upon. Needs to be a full document, complete with body.\n   * @return Element\n  **/\n  _grabArticle: function (page) {\n    this.log(\"**** grabArticle ****\");\n    var doc = this._doc;\n    var isPaging = page !== null;\n    page = page ? page : this._doc.body;\n\n    // We can't grab an article if we don't have a page!\n    if (!page) {\n      this.log(\"No body found in document. Abort.\");\n      return null;\n    }\n\n    var pageCacheHtml = page.innerHTML;\n\n    while (true) {\n      this.log(\"Starting grabArticle loop\");\n      var stripUnlikelyCandidates = this._flagIsActive(this.FLAG_STRIP_UNLIKELYS);\n\n      // First, node prepping. Trash nodes that look cruddy (like ones with the\n      // class name \"comment\", etc), and turn divs into P tags where they have been\n      // used inappropriately (as in, where they contain no other block level elements.)\n      var elementsToScore = [];\n      var node = this._doc.documentElement;\n\n      let shouldRemoveTitleHeader = true;\n\n      while (node) {\n\n        if (node.tagName === \"HTML\") {\n          this._articleLang = node.getAttribute(\"lang\");\n        }\n\n        var matchString = node.className + \" \" + node.id;\n\n        if (!this._isProbablyVisible(node)) {\n          this.log(\"Removing hidden node - \" + matchString);\n          node = this._removeAndGetNext(node);\n          continue;\n        }\n\n        // User is not able to see elements applied with both \"aria-modal = true\" and \"role = dialog\"\n        if (node.getAttribute(\"aria-modal\") == \"true\" && node.getAttribute(\"role\") == \"dialog\") {\n          node = this._removeAndGetNext(node);\n          continue;\n        }\n\n        // Check to see if this node is a byline, and remove it if it is.\n        if (this._checkByline(node, matchString)) {\n          node = this._removeAndGetNext(node);\n          continue;\n        }\n\n        if (shouldRemoveTitleHeader && this._headerDuplicatesTitle(node)) {\n          this.log(\"Removing header: \", node.textContent.trim(), this._articleTitle.trim());\n          shouldRemoveTitleHeader = false;\n          node = this._removeAndGetNext(node);\n          continue;\n        }\n\n        // Remove unlikely candidates\n        if (stripUnlikelyCandidates) {\n          if (this.REGEXPS.unlikelyCandidates.test(matchString) &&\n              !this.REGEXPS.okMaybeItsACandidate.test(matchString) &&\n              !this._hasAncestorTag(node, \"table\") &&\n              !this._hasAncestorTag(node, \"code\") &&\n              node.tagName !== \"BODY\" &&\n              node.tagName !== \"A\") {\n            this.log(\"Removing unlikely candidate - \" + matchString);\n            node = this._removeAndGetNext(node);\n            continue;\n          }\n\n          if (this.UNLIKELY_ROLES.includes(node.getAttribute(\"role\"))) {\n            this.log(\"Removing content with role \" + node.getAttribute(\"role\") + \" - \" + matchString);\n            node = this._removeAndGetNext(node);\n            continue;\n          }\n        }\n\n        // Remove DIV, SECTION, and HEADER nodes without any content(e.g. text, image, video, or iframe).\n        if ((node.tagName === \"DIV\" || node.tagName === \"SECTION\" || node.tagName === \"HEADER\" ||\n             node.tagName === \"H1\" || node.tagName === \"H2\" || node.tagName === \"H3\" ||\n             node.tagName === \"H4\" || node.tagName === \"H5\" || node.tagName === \"H6\") &&\n            this._isElementWithoutContent(node)) {\n          node = this._removeAndGetNext(node);\n          continue;\n        }\n\n        if (this.DEFAULT_TAGS_TO_SCORE.indexOf(node.tagName) !== -1) {\n          elementsToScore.push(node);\n        }\n\n        // Turn all divs that don't have children block level elements into p's\n        if (node.tagName === \"DIV\") {\n          // Put phrasing content into paragraphs.\n          var p = null;\n          var childNode = node.firstChild;\n          while (childNode) {\n            var nextSibling = childNode.nextSibling;\n            if (this._isPhrasingContent(childNode)) {\n              if (p !== null) {\n                p.appendChild(childNode);\n              } else if (!this._isWhitespace(childNode)) {\n                p = doc.createElement(\"p\");\n                node.replaceChild(p, childNode);\n                p.appendChild(childNode);\n              }\n            } else if (p !== null) {\n              while (p.lastChild && this._isWhitespace(p.lastChild)) {\n                p.removeChild(p.lastChild);\n              }\n              p = null;\n            }\n            childNode = nextSibling;\n          }\n\n          // Sites like http://mobile.slate.com encloses each paragraph with a DIV\n          // element. DIVs with only a P element inside and no text content can be\n          // safely converted into plain P elements to avoid confusing the scoring\n          // algorithm with DIVs with are, in practice, paragraphs.\n          if (this._hasSingleTagInsideElement(node, \"P\") && this._getLinkDensity(node) < 0.25) {\n            var newNode = node.children[0];\n            node.parentNode.replaceChild(newNode, node);\n            node = newNode;\n            elementsToScore.push(node);\n          } else if (!this._hasChildBlockElement(node)) {\n            node = this._setNodeTag(node, \"P\");\n            elementsToScore.push(node);\n          }\n        }\n        node = this._getNextNode(node);\n      }\n\n      /**\n       * Loop through all paragraphs, and assign a score to them based on how content-y they look.\n       * Then add their score to their parent node.\n       *\n       * A score is determined by things like number of commas, class names, etc. Maybe eventually link density.\n      **/\n      var candidates = [];\n      this._forEachNode(elementsToScore, function(elementToScore) {\n        if (!elementToScore.parentNode || typeof(elementToScore.parentNode.tagName) === \"undefined\")\n          return;\n\n        // If this paragraph is less than 25 characters, don't even count it.\n        var innerText = this._getInnerText(elementToScore);\n        if (innerText.length < 25)\n          return;\n\n        // Exclude nodes with no ancestor.\n        var ancestors = this._getNodeAncestors(elementToScore, 5);\n        if (ancestors.length === 0)\n          return;\n\n        var contentScore = 0;\n\n        // Add a point for the paragraph itself as a base.\n        contentScore += 1;\n\n        // Add points for any commas within this paragraph.\n        contentScore += innerText.split(this.REGEXPS.commas).length;\n\n        // For every 100 characters in this paragraph, add another point. Up to 3 points.\n        contentScore += Math.min(Math.floor(innerText.length / 100), 3);\n\n        // Initialize and score ancestors.\n        this._forEachNode(ancestors, function(ancestor, level) {\n          if (!ancestor.tagName || !ancestor.parentNode || typeof(ancestor.parentNode.tagName) === \"undefined\")\n            return;\n\n          if (typeof(ancestor.readability) === \"undefined\") {\n            this._initializeNode(ancestor);\n            candidates.push(ancestor);\n          }\n\n          // Node score divider:\n          // - parent:             1 (no division)\n          // - grandparent:        2\n          // - great grandparent+: ancestor level * 3\n          if (level === 0)\n            var scoreDivider = 1;\n          else if (level === 1)\n            scoreDivider = 2;\n          else\n            scoreDivider = level * 3;\n          ancestor.readability.contentScore += contentScore / scoreDivider;\n        });\n      });\n\n      // After we've calculated scores, loop through all of the possible\n      // candidate nodes we found and find the one with the highest score.\n      var topCandidates = [];\n      for (var c = 0, cl = candidates.length; c < cl; c += 1) {\n        var candidate = candidates[c];\n\n        // Scale the final candidates score based on link density. Good content\n        // should have a relatively small link density (5% or less) and be mostly\n        // unaffected by this operation.\n        var candidateScore = candidate.readability.contentScore * (1 - this._getLinkDensity(candidate));\n        candidate.readability.contentScore = candidateScore;\n\n        this.log(\"Candidate:\", candidate, \"with score \" + candidateScore);\n\n        for (var t = 0; t < this._nbTopCandidates; t++) {\n          var aTopCandidate = topCandidates[t];\n\n          if (!aTopCandidate || candidateScore > aTopCandidate.readability.contentScore) {\n            topCandidates.splice(t, 0, candidate);\n            if (topCandidates.length > this._nbTopCandidates)\n              topCandidates.pop();\n            break;\n          }\n        }\n      }\n\n      var topCandidate = topCandidates[0] || null;\n      var neededToCreateTopCandidate = false;\n      var parentOfTopCandidate;\n\n      // If we still have no top candidate, just use the body as a last resort.\n      // We also have to copy the body node so it is something we can modify.\n      if (topCandidate === null || topCandidate.tagName === \"BODY\") {\n        // Move all of the page's children into topCandidate\n        topCandidate = doc.createElement(\"DIV\");\n        neededToCreateTopCandidate = true;\n        // Move everything (not just elements, also text nodes etc.) into the container\n        // so we even include text directly in the body:\n        while (page.firstChild) {\n          this.log(\"Moving child out:\", page.firstChild);\n          topCandidate.appendChild(page.firstChild);\n        }\n\n        page.appendChild(topCandidate);\n\n        this._initializeNode(topCandidate);\n      } else if (topCandidate) {\n        // Find a better top candidate node if it contains (at least three) nodes which belong to `topCandidates` array\n        // and whose scores are quite closed with current `topCandidate` node.\n        var alternativeCandidateAncestors = [];\n        for (var i = 1; i < topCandidates.length; i++) {\n          if (topCandidates[i].readability.contentScore / topCandidate.readability.contentScore >= 0.75) {\n            alternativeCandidateAncestors.push(this._getNodeAncestors(topCandidates[i]));\n          }\n        }\n        var MINIMUM_TOPCANDIDATES = 3;\n        if (alternativeCandidateAncestors.length >= MINIMUM_TOPCANDIDATES) {\n          parentOfTopCandidate = topCandidate.parentNode;\n          while (parentOfTopCandidate.tagName !== \"BODY\") {\n            var listsContainingThisAncestor = 0;\n            for (var ancestorIndex = 0; ancestorIndex < alternativeCandidateAncestors.length && listsContainingThisAncestor < MINIMUM_TOPCANDIDATES; ancestorIndex++) {\n              listsContainingThisAncestor += Number(alternativeCandidateAncestors[ancestorIndex].includes(parentOfTopCandidate));\n            }\n            if (listsContainingThisAncestor >= MINIMUM_TOPCANDIDATES) {\n              topCandidate = parentOfTopCandidate;\n              break;\n            }\n            parentOfTopCandidate = parentOfTopCandidate.parentNode;\n          }\n        }\n        if (!topCandidate.readability) {\n          this._initializeNode(topCandidate);\n        }\n\n        // Because of our bonus system, parents of candidates might have scores\n        // themselves. They get half of the node. There won't be nodes with higher\n        // scores than our topCandidate, but if we see the score going *up* in the first\n        // few steps up the tree, that's a decent sign that there might be more content\n        // lurking in other places that we want to unify in. The sibling stuff\n        // below does some of that - but only if we've looked high enough up the DOM\n        // tree.\n        parentOfTopCandidate = topCandidate.parentNode;\n        var lastScore = topCandidate.readability.contentScore;\n        // The scores shouldn't get too low.\n        var scoreThreshold = lastScore / 3;\n        while (parentOfTopCandidate.tagName !== \"BODY\") {\n          if (!parentOfTopCandidate.readability) {\n            parentOfTopCandidate = parentOfTopCandidate.parentNode;\n            continue;\n          }\n          var parentScore = parentOfTopCandidate.readability.contentScore;\n          if (parentScore < scoreThreshold)\n            break;\n          if (parentScore > lastScore) {\n            // Alright! We found a better parent to use.\n            topCandidate = parentOfTopCandidate;\n            break;\n          }\n          lastScore = parentOfTopCandidate.readability.contentScore;\n          parentOfTopCandidate = parentOfTopCandidate.parentNode;\n        }\n\n        // If the top candidate is the only child, use parent instead. This will help sibling\n        // joining logic when adjacent content is actually located in parent's sibling node.\n        parentOfTopCandidate = topCandidate.parentNode;\n        while (parentOfTopCandidate.tagName != \"BODY\" && parentOfTopCandidate.children.length == 1) {\n          topCandidate = parentOfTopCandidate;\n          parentOfTopCandidate = topCandidate.parentNode;\n        }\n        if (!topCandidate.readability) {\n          this._initializeNode(topCandidate);\n        }\n      }\n\n      // Now that we have the top candidate, look through its siblings for content\n      // that might also be related. Things like preambles, content split by ads\n      // that we removed, etc.\n      var articleContent = doc.createElement(\"DIV\");\n      if (isPaging)\n        articleContent.id = \"readability-content\";\n\n      var siblingScoreThreshold = Math.max(10, topCandidate.readability.contentScore * 0.2);\n      // Keep potential top candidate's parent node to try to get text direction of it later.\n      parentOfTopCandidate = topCandidate.parentNode;\n      var siblings = parentOfTopCandidate.children;\n\n      for (var s = 0, sl = siblings.length; s < sl; s++) {\n        var sibling = siblings[s];\n        var append = false;\n\n        this.log(\"Looking at sibling node:\", sibling, sibling.readability ? (\"with score \" + sibling.readability.contentScore) : \"\");\n        this.log(\"Sibling has score\", sibling.readability ? sibling.readability.contentScore : \"Unknown\");\n\n        if (sibling === topCandidate) {\n          append = true;\n        } else {\n          var contentBonus = 0;\n\n          // Give a bonus if sibling nodes and top candidates have the example same classname\n          if (sibling.className === topCandidate.className && topCandidate.className !== \"\")\n            contentBonus += topCandidate.readability.contentScore * 0.2;\n\n          if (sibling.readability &&\n              ((sibling.readability.contentScore + contentBonus) >= siblingScoreThreshold)) {\n            append = true;\n          } else if (sibling.nodeName === \"P\") {\n            var linkDensity = this._getLinkDensity(sibling);\n            var nodeContent = this._getInnerText(sibling);\n            var nodeLength = nodeContent.length;\n\n            if (nodeLength > 80 && linkDensity < 0.25) {\n              append = true;\n            } else if (nodeLength < 80 && nodeLength > 0 && linkDensity === 0 &&\n                       nodeContent.search(/\\.( |$)/) !== -1) {\n              append = true;\n            }\n          }\n        }\n\n        if (append) {\n          this.log(\"Appending node:\", sibling);\n\n          if (this.ALTER_TO_DIV_EXCEPTIONS.indexOf(sibling.nodeName) === -1) {\n            // We have a node that isn't a common block level element, like a form or td tag.\n            // Turn it into a div so it doesn't get filtered out later by accident.\n            this.log(\"Altering sibling:\", sibling, \"to div.\");\n\n            sibling = this._setNodeTag(sibling, \"DIV\");\n          }\n\n          articleContent.appendChild(sibling);\n          // Fetch children again to make it compatible\n          // with DOM parsers without live collection support.\n          siblings = parentOfTopCandidate.children;\n          // siblings is a reference to the children array, and\n          // sibling is removed from the array when we call appendChild().\n          // As a result, we must revisit this index since the nodes\n          // have been shifted.\n          s -= 1;\n          sl -= 1;\n        }\n      }\n\n      if (this._debug)\n        this.log(\"Article content pre-prep: \" + articleContent.innerHTML);\n      // So we have all of the content that we need. Now we clean it up for presentation.\n      this._prepArticle(articleContent);\n      if (this._debug)\n        this.log(\"Article content post-prep: \" + articleContent.innerHTML);\n\n      if (neededToCreateTopCandidate) {\n        // We already created a fake div thing, and there wouldn't have been any siblings left\n        // for the previous loop, so there's no point trying to create a new div, and then\n        // move all the children over. Just assign IDs and class names here. No need to append\n        // because that already happened anyway.\n        topCandidate.id = \"readability-page-1\";\n        topCandidate.className = \"page\";\n      } else {\n        var div = doc.createElement(\"DIV\");\n        div.id = \"readability-page-1\";\n        div.className = \"page\";\n        while (articleContent.firstChild) {\n          div.appendChild(articleContent.firstChild);\n        }\n        articleContent.appendChild(div);\n      }\n\n      if (this._debug)\n        this.log(\"Article content after paging: \" + articleContent.innerHTML);\n\n      var parseSuccessful = true;\n\n      // Now that we've gone through the full algorithm, check to see if\n      // we got any meaningful content. If we didn't, we may need to re-run\n      // grabArticle with different flags set. This gives us a higher likelihood of\n      // finding the content, and the sieve approach gives us a higher likelihood of\n      // finding the -right- content.\n      var textLength = this._getInnerText(articleContent, true).length;\n      if (textLength < this._charThreshold) {\n        parseSuccessful = false;\n        page.innerHTML = pageCacheHtml;\n\n        if (this._flagIsActive(this.FLAG_STRIP_UNLIKELYS)) {\n          this._removeFlag(this.FLAG_STRIP_UNLIKELYS);\n          this._attempts.push({articleContent: articleContent, textLength: textLength});\n        } else if (this._flagIsActive(this.FLAG_WEIGHT_CLASSES)) {\n          this._removeFlag(this.FLAG_WEIGHT_CLASSES);\n          this._attempts.push({articleContent: articleContent, textLength: textLength});\n        } else if (this._flagIsActive(this.FLAG_CLEAN_CONDITIONALLY)) {\n          this._removeFlag(this.FLAG_CLEAN_CONDITIONALLY);\n          this._attempts.push({articleContent: articleContent, textLength: textLength});\n        } else {\n          this._attempts.push({articleContent: articleContent, textLength: textLength});\n          // No luck after removing flags, just return the longest text we found during the different loops\n          this._attempts.sort(function (a, b) {\n            return b.textLength - a.textLength;\n          });\n\n          // But first check if we actually have something\n          if (!this._attempts[0].textLength) {\n            return null;\n          }\n\n          articleContent = this._attempts[0].articleContent;\n          parseSuccessful = true;\n        }\n      }\n\n      if (parseSuccessful) {\n        // Find out text direction from ancestors of final top candidate.\n        var ancestors = [parentOfTopCandidate, topCandidate].concat(this._getNodeAncestors(parentOfTopCandidate));\n        this._someNode(ancestors, function(ancestor) {\n          if (!ancestor.tagName)\n            return false;\n          var articleDir = ancestor.getAttribute(\"dir\");\n          if (articleDir) {\n            this._articleDir = articleDir;\n            return true;\n          }\n          return false;\n        });\n        return articleContent;\n      }\n    }\n  },\n\n  /**\n   * Check whether the input string could be a byline.\n   * This verifies that the input is a string, and that the length\n   * is less than 100 chars.\n   *\n   * @param possibleByline {string} - a string to check whether its a byline.\n   * @return Boolean - whether the input string is a byline.\n   */\n  _isValidByline: function(byline) {\n    if (typeof byline == \"string\" || byline instanceof String) {\n      byline = byline.trim();\n      return (byline.length > 0) && (byline.length < 100);\n    }\n    return false;\n  },\n\n  /**\n   * Converts some of the common HTML entities in string to their corresponding characters.\n   *\n   * @param str {string} - a string to unescape.\n   * @return string without HTML entity.\n   */\n  _unescapeHtmlEntities: function(str) {\n    if (!str) {\n      return str;\n    }\n\n    var htmlEscapeMap = this.HTML_ESCAPE_MAP;\n    return str.replace(/&(quot|amp|apos|lt|gt);/g, function(_, tag) {\n      return htmlEscapeMap[tag];\n    }).replace(/&#(?:x([0-9a-z]{1,4})|([0-9]{1,4}));/gi, function(_, hex, numStr) {\n      var num = parseInt(hex || numStr, hex ? 16 : 10);\n      return String.fromCharCode(num);\n    });\n  },\n\n  /**\n   * Try to extract metadata from JSON-LD object.\n   * For now, only Schema.org objects of type Article or its subtypes are supported.\n   * @return Object with any metadata that could be extracted (possibly none)\n   */\n  _getJSONLD: function (doc) {\n    var scripts = this._getAllNodesWithTag(doc, [\"script\"]);\n\n    var metadata;\n\n    this._forEachNode(scripts, function(jsonLdElement) {\n      if (!metadata && jsonLdElement.getAttribute(\"type\") === \"application/ld+json\") {\n        try {\n          // Strip CDATA markers if present\n          var content = jsonLdElement.textContent.replace(/^\\s*<!\\[CDATA\\[|\\]\\]>\\s*$/g, \"\");\n          var parsed = JSON.parse(content);\n          if (\n            !parsed[\"@context\"] ||\n            !parsed[\"@context\"].match(/^https?\\:\\/\\/schema\\.org$/)\n          ) {\n            return;\n          }\n\n          if (!parsed[\"@type\"] && Array.isArray(parsed[\"@graph\"])) {\n            parsed = parsed[\"@graph\"].find(function(it) {\n              return (it[\"@type\"] || \"\").match(\n                this.REGEXPS.jsonLdArticleTypes\n              );\n            });\n          }\n\n          if (\n            !parsed ||\n            !parsed[\"@type\"] ||\n            !parsed[\"@type\"].match(this.REGEXPS.jsonLdArticleTypes)\n          ) {\n            return;\n          }\n\n          metadata = {};\n\n          if (typeof parsed.name === \"string\" && typeof parsed.headline === \"string\" && parsed.name !== parsed.headline) {\n            // we have both name and headline element in the JSON-LD. They should both be the same but some websites like aktualne.cz\n            // put their own name into \"name\" and the article title to \"headline\" which confuses Readability. So we try to check if either\n            // \"name\" or \"headline\" closely matches the html title, and if so, use that one. If not, then we use \"name\" by default.\n\n            var title = this._getArticleTitle();\n            var nameMatches = this._textSimilarity(parsed.name, title) > 0.75;\n            var headlineMatches = this._textSimilarity(parsed.headline, title) > 0.75;\n\n            if (headlineMatches && !nameMatches) {\n              metadata.title = parsed.headline;\n            } else {\n              metadata.title = parsed.name;\n            }\n          } else if (typeof parsed.name === \"string\") {\n            metadata.title = parsed.name.trim();\n          } else if (typeof parsed.headline === \"string\") {\n            metadata.title = parsed.headline.trim();\n          }\n          if (parsed.author) {\n            if (typeof parsed.author.name === \"string\") {\n              metadata.byline = parsed.author.name.trim();\n            } else if (Array.isArray(parsed.author) && parsed.author[0] && typeof parsed.author[0].name === \"string\") {\n              metadata.byline = parsed.author\n                .filter(function(author) {\n                  return author && typeof author.name === \"string\";\n                })\n                .map(function(author) {\n                  return author.name.trim();\n                })\n                .join(\", \");\n            }\n          }\n          if (typeof parsed.description === \"string\") {\n            metadata.excerpt = parsed.description.trim();\n          }\n          if (\n            parsed.publisher &&\n            typeof parsed.publisher.name === \"string\"\n          ) {\n            metadata.siteName = parsed.publisher.name.trim();\n          }\n          if (typeof parsed.datePublished === \"string\") {\n            metadata.datePublished = parsed.datePublished.trim();\n          }\n          return;\n        } catch (err) {\n          this.log(err.message);\n        }\n      }\n    });\n    return metadata ? metadata : {};\n  },\n\n  /**\n   * Attempts to get excerpt and byline metadata for the article.\n   *\n   * @param {Object} jsonld \u2014 object containing any metadata that\n   * could be extracted from JSON-LD object.\n   *\n   * @return Object with optional \"excerpt\" and \"byline\" properties\n   */\n  _getArticleMetadata: function(jsonld) {\n    var metadata = {};\n    var values = {};\n    var metaElements = this._doc.getElementsByTagName(\"meta\");\n\n    // property is a space-separated list of values\n    var propertyPattern = /\\s*(article|dc|dcterm|og|twitter)\\s*:\\s*(author|creator|description|published_time|title|site_name)\\s*/gi;\n\n    // name is a single value\n    var namePattern = /^\\s*(?:(dc|dcterm|og|twitter|weibo:(article|webpage))\\s*[\\.:]\\s*)?(author|creator|description|title|site_name)\\s*$/i;\n\n    // Find description tags.\n    this._forEachNode(metaElements, function(element) {\n      var elementName = element.getAttribute(\"name\");\n      var elementProperty = element.getAttribute(\"property\");\n      var content = element.getAttribute(\"content\");\n      if (!content) {\n        return;\n      }\n      var matches = null;\n      var name = null;\n\n      if (elementProperty) {\n        matches = elementProperty.match(propertyPattern);\n        if (matches) {\n          // Convert to lowercase, and remove any whitespace\n          // so we can match below.\n          name = matches[0].toLowerCase().replace(/\\s/g, \"\");\n          // multiple authors\n          values[name] = content.trim();\n        }\n      }\n      if (!matches && elementName && namePattern.test(elementName)) {\n        name = elementName;\n        if (content) {\n          // Convert to lowercase, remove any whitespace, and convert dots\n          // to colons so we can match below.\n          name = name.toLowerCase().replace(/\\s/g, \"\").replace(/\\./g, \":\");\n          values[name] = content.trim();\n        }\n      }\n    });\n\n    // get title\n    metadata.title = jsonld.title ||\n                     values[\"dc:title\"] ||\n                     values[\"dcterm:title\"] ||\n                     values[\"og:title\"] ||\n                     values[\"weibo:article:title\"] ||\n                     values[\"weibo:webpage:title\"] ||\n                     values[\"title\"] ||\n                     values[\"twitter:title\"];\n\n    if (!metadata.title) {\n      metadata.title = this._getArticleTitle();\n    }\n\n    // get author\n    metadata.byline = jsonld.byline ||\n                      values[\"dc:creator\"] ||\n                      values[\"dcterm:creator\"] ||\n                      values[\"author\"];\n\n    // get description\n    metadata.excerpt = jsonld.excerpt ||\n                       values[\"dc:description\"] ||\n                       values[\"dcterm:description\"] ||\n                       values[\"og:description\"] ||\n                       values[\"weibo:article:description\"] ||\n                       values[\"weibo:webpage:description\"] ||\n                       values[\"description\"] ||\n                       values[\"twitter:description\"];\n\n    // get site name\n    metadata.siteName = jsonld.siteName ||\n                        values[\"og:site_name\"];\n\n    // get article published time\n    metadata.publishedTime = jsonld.datePublished ||\n      values[\"article:published_time\"] || null;\n\n    // in many sites the meta value is escaped with HTML entities,\n    // so here we need to unescape it\n    metadata.title = this._unescapeHtmlEntities(metadata.title);\n    metadata.byline = this._unescapeHtmlEntities(metadata.byline);\n    metadata.excerpt = this._unescapeHtmlEntities(metadata.excerpt);\n    metadata.siteName = this._unescapeHtmlEntities(metadata.siteName);\n    metadata.publishedTime = this._unescapeHtmlEntities(metadata.publishedTime);\n\n    return metadata;\n  },\n\n  /**\n   * Check if node is image, or if node contains exactly only one image\n   * whether as a direct child or as its descendants.\n   *\n   * @param Element\n  **/\n  _isSingleImage: function(node) {\n    if (node.tagName === \"IMG\") {\n      return true;\n    }\n\n    if (node.children.length !== 1 || node.textContent.trim() !== \"\") {\n      return false;\n    }\n\n    return this._isSingleImage(node.children[0]);\n  },\n\n  /**\n   * Find all <noscript> that are located after <img> nodes, and which contain only one\n   * <img> element. Replace the first image with the image from inside the <noscript> tag,\n   * and remove the <noscript> tag. This improves the quality of the images we use on\n   * some sites (e.g. Medium).\n   *\n   * @param Element\n  **/\n  _unwrapNoscriptImages: function(doc) {\n    // Find img without source or attributes that might contains image, and remove it.\n    // This is done to prevent a placeholder img is replaced by img from noscript in next step.\n    var imgs = Array.from(doc.getElementsByTagName(\"img\"));\n    this._forEachNode(imgs, function(img) {\n      for (var i = 0; i < img.attributes.length; i++) {\n        var attr = img.attributes[i];\n        switch (attr.name) {\n          case \"src\":\n          case \"srcset\":\n          case \"data-src\":\n          case \"data-srcset\":\n            return;\n        }\n\n        if (/\\.(jpg|jpeg|png|webp)/i.test(attr.value)) {\n          return;\n        }\n      }\n\n      img.parentNode.removeChild(img);\n    });\n\n    // Next find noscript and try to extract its image\n    var noscripts = Array.from(doc.getElementsByTagName(\"noscript\"));\n    this._forEachNode(noscripts, function(noscript) {\n      // Parse content of noscript and make sure it only contains image\n      var tmp = doc.createElement(\"div\");\n      tmp.innerHTML = noscript.innerHTML;\n      if (!this._isSingleImage(tmp)) {\n        return;\n      }\n\n      // If noscript has previous sibling and it only contains image,\n      // replace it with noscript content. However we also keep old\n      // attributes that might contains image.\n      var prevElement = noscript.previousElementSibling;\n      if (prevElement && this._isSingleImage(prevElement)) {\n        var prevImg = prevElement;\n        if (prevImg.tagName !== \"IMG\") {\n          prevImg = prevElement.getElementsByTagName(\"img\")[0];\n        }\n\n        var newImg = tmp.getElementsByTagName(\"img\")[0];\n        for (var i = 0; i < prevImg.attributes.length; i++) {\n          var attr = prevImg.attributes[i];\n          if (attr.value === \"\") {\n            continue;\n          }\n\n          if (attr.name === \"src\" || attr.name === \"srcset\" || /\\.(jpg|jpeg|png|webp)/i.test(attr.value)) {\n            if (newImg.getAttribute(attr.name) === attr.value) {\n              continue;\n            }\n\n            var attrName = attr.name;\n            if (newImg.hasAttribute(attrName)) {\n              attrName = \"data-old-\" + attrName;\n            }\n\n            newImg.setAttribute(attrName, attr.value);\n          }\n        }\n\n        noscript.parentNode.replaceChild(tmp.firstElementChild, prevElement);\n      }\n    });\n  },\n\n  /**\n   * Removes script tags from the document.\n   *\n   * @param Element\n  **/\n  _removeScripts: function(doc) {\n    this._removeNodes(this._getAllNodesWithTag(doc, [\"script\", \"noscript\"]));\n  },\n\n  /**\n   * Check if this node has only whitespace and a single element with given tag\n   * Returns false if the DIV node contains non-empty text nodes\n   * or if it contains no element with given tag or more than 1 element.\n   *\n   * @param Element\n   * @param string tag of child element\n  **/\n  _hasSingleTagInsideElement: function(element, tag) {\n    // There should be exactly 1 element child with given tag\n    if (element.children.length != 1 || element.children[0].tagName !== tag) {\n      return false;\n    }\n\n    // And there should be no text nodes with real content\n    return !this._someNode(element.childNodes, function(node) {\n      return node.nodeType === this.TEXT_NODE &&\n             this.REGEXPS.hasContent.test(node.textContent);\n    });\n  },\n\n  _isElementWithoutContent: function(node) {\n    return node.nodeType === this.ELEMENT_NODE &&\n      node.textContent.trim().length == 0 &&\n      (node.children.length == 0 ||\n       node.children.length == node.getElementsByTagName(\"br\").length + node.getElementsByTagName(\"hr\").length);\n  },\n\n  /**\n   * Determine whether element has any children block level elements.\n   *\n   * @param Element\n   */\n  _hasChildBlockElement: function (element) {\n    return this._someNode(element.childNodes, function(node) {\n      return this.DIV_TO_P_ELEMS.has(node.tagName) ||\n             this._hasChildBlockElement(node);\n    });\n  },\n\n  /***\n   * Determine if a node qualifies as phrasing content.\n   * https://developer.mozilla.org/en-US/docs/Web/Guide/HTML/Content_categories#Phrasing_content\n  **/\n  _isPhrasingContent: function(node) {\n    return node.nodeType === this.TEXT_NODE || this.PHRASING_ELEMS.indexOf(node.tagName) !== -1 ||\n      ((node.tagName === \"A\" || node.tagName === \"DEL\" || node.tagName === \"INS\") &&\n        this._everyNode(node.childNodes, this._isPhrasingContent));\n  },\n\n  _isWhitespace: function(node) {\n    return (node.nodeType === this.TEXT_NODE && node.textContent.trim().length === 0) ||\n           (node.nodeType === this.ELEMENT_NODE && node.tagName === \"BR\");\n  },\n\n  /**\n   * Get the inner text of a node - cross browser compatibly.\n   * This also strips out any excess whitespace to be found.\n   *\n   * @param Element\n   * @param Boolean normalizeSpaces (default: true)\n   * @return string\n  **/\n  _getInnerText: function(e, normalizeSpaces) {\n    normalizeSpaces = (typeof normalizeSpaces === \"undefined\") ? true : normalizeSpaces;\n    var textContent = e.textContent.trim();\n\n    if (normalizeSpaces) {\n      return textContent.replace(this.REGEXPS.normalize, \" \");\n    }\n    return textContent;\n  },\n\n  /**\n   * Get the number of times a string s appears in the node e.\n   *\n   * @param Element\n   * @param string - what to split on. Default is \",\"\n   * @return number (integer)\n  **/\n  _getCharCount: function(e, s) {\n    s = s || \",\";\n    return this._getInnerText(e).split(s).length - 1;\n  },\n\n  /**\n   * Remove the style attribute on every e and under.\n   * TODO: Test if getElementsByTagName(*) is faster.\n   *\n   * @param Element\n   * @return void\n  **/\n  _cleanStyles: function(e) {\n    if (!e || e.tagName.toLowerCase() === \"svg\")\n      return;\n\n    // Remove `style` and deprecated presentational attributes\n    for (var i = 0; i < this.PRESENTATIONAL_ATTRIBUTES.length; i++) {\n      e.removeAttribute(this.PRESENTATIONAL_ATTRIBUTES[i]);\n    }\n\n    if (this.DEPRECATED_SIZE_ATTRIBUTE_ELEMS.indexOf(e.tagName) !== -1) {\n      e.removeAttribute(\"width\");\n      e.removeAttribute(\"height\");\n    }\n\n    var cur = e.firstElementChild;\n    while (cur !== null) {\n      this._cleanStyles(cur);\n      cur = cur.nextElementSibling;\n    }\n  },\n\n  /**\n   * Get the density of links as a percentage of the content\n   * This is the amount of text that is inside a link divided by the total text in the node.\n   *\n   * @param Element\n   * @return number (float)\n  **/\n  _getLinkDensity: function(element) {\n    var textLength = this._getInnerText(element).length;\n    if (textLength === 0)\n      return 0;\n\n    var linkLength = 0;\n\n    // XXX implement _reduceNodeList?\n    this._forEachNode(element.getElementsByTagName(\"a\"), function(linkNode) {\n      var href = linkNode.getAttribute(\"href\");\n      var coefficient = href && this.REGEXPS.hashUrl.test(href) ? 0.3 : 1;\n      linkLength += this._getInnerText(linkNode).length * coefficient;\n    });\n\n    return linkLength / textLength;\n  },\n\n  /**\n   * Get an elements class/id weight. Uses regular expressions to tell if this\n   * element looks good or bad.\n   *\n   * @param Element\n   * @return number (Integer)\n  **/\n  _getClassWeight: function(e) {\n    if (!this._flagIsActive(this.FLAG_WEIGHT_CLASSES))\n      return 0;\n\n    var weight = 0;\n\n    // Look for a special classname\n    if (typeof(e.className) === \"string\" && e.className !== \"\") {\n      if (this.REGEXPS.negative.test(e.className))\n        weight -= 25;\n\n      if (this.REGEXPS.positive.test(e.className))\n        weight += 25;\n    }\n\n    // Look for a special ID\n    if (typeof(e.id) === \"string\" && e.id !== \"\") {\n      if (this.REGEXPS.negative.test(e.id))\n        weight -= 25;\n\n      if (this.REGEXPS.positive.test(e.id))\n        weight += 25;\n    }\n\n    return weight;\n  },\n\n  /**\n   * Clean a node of all elements of type \"tag\".\n   * (Unless it's a youtube/vimeo video. People love movies.)\n   *\n   * @param Element\n   * @param string tag to clean\n   * @return void\n   **/\n  _clean: function(e, tag) {\n    var isEmbed = [\"object\", \"embed\", \"iframe\"].indexOf(tag) !== -1;\n\n    this._removeNodes(this._getAllNodesWithTag(e, [tag]), function(element) {\n      // Allow youtube and vimeo videos through as people usually want to see those.\n      if (isEmbed) {\n        // First, check the elements attributes to see if any of them contain youtube or vimeo\n        for (var i = 0; i < element.attributes.length; i++) {\n          if (this._allowedVideoRegex.test(element.attributes[i].value)) {\n            return false;\n          }\n        }\n\n        // For embed with <object> tag, check inner HTML as well.\n        if (element.tagName === \"object\" && this._allowedVideoRegex.test(element.innerHTML)) {\n          return false;\n        }\n      }\n\n      return true;\n    });\n  },\n\n  /**\n   * Check if a given node has one of its ancestor tag name matching the\n   * provided one.\n   * @param  HTMLElement node\n   * @param  String      tagName\n   * @param  Number      maxDepth\n   * @param  Function    filterFn a filter to invoke to determine whether this node 'counts'\n   * @return Boolean\n   */\n  _hasAncestorTag: function(node, tagName, maxDepth, filterFn) {\n    maxDepth = maxDepth || 3;\n    tagName = tagName.toUpperCase();\n    var depth = 0;\n    while (node.parentNode) {\n      if (maxDepth > 0 && depth > maxDepth)\n        return false;\n      if (node.parentNode.tagName === tagName && (!filterFn || filterFn(node.parentNode)))\n        return true;\n      node = node.parentNode;\n      depth++;\n    }\n    return false;\n  },\n\n  /**\n   * Return an object indicating how many rows and columns this table has.\n   */\n  _getRowAndColumnCount: function(table) {\n    var rows = 0;\n    var columns = 0;\n    var trs = table.getElementsByTagName(\"tr\");\n    for (var i = 0; i < trs.length; i++) {\n      var rowspan = trs[i].getAttribute(\"rowspan\") || 0;\n      if (rowspan) {\n        rowspan = parseInt(rowspan, 10);\n      }\n      rows += (rowspan || 1);\n\n      // Now look for column-related info\n      var columnsInThisRow = 0;\n      var cells = trs[i].getElementsByTagName(\"td\");\n      for (var j = 0; j < cells.length; j++) {\n        var colspan = cells[j].getAttribute(\"colspan\") || 0;\n        if (colspan) {\n          colspan = parseInt(colspan, 10);\n        }\n        columnsInThisRow += (colspan || 1);\n      }\n      columns = Math.max(columns, columnsInThisRow);\n    }\n    return {rows: rows, columns: columns};\n  },\n\n  /**\n   * Look for 'data' (as opposed to 'layout') tables, for which we use\n   * similar checks as\n   * https://searchfox.org/mozilla-central/rev/f82d5c549f046cb64ce5602bfd894b7ae807c8f8/accessible/generic/TableAccessible.cpp#19\n   */\n  _markDataTables: function(root) {\n    var tables = root.getElementsByTagName(\"table\");\n    for (var i = 0; i < tables.length; i++) {\n      var table = tables[i];\n      var role = table.getAttribute(\"role\");\n      if (role == \"presentation\") {\n        table._readabilityDataTable = false;\n        continue;\n      }\n      var datatable = table.getAttribute(\"datatable\");\n      if (datatable == \"0\") {\n        table._readabilityDataTable = false;\n        continue;\n      }\n      var summary = table.getAttribute(\"summary\");\n      if (summary) {\n        table._readabilityDataTable = true;\n        continue;\n      }\n\n      var caption = table.getElementsByTagName(\"caption\")[0];\n      if (caption && caption.childNodes.length > 0) {\n        table._readabilityDataTable = true;\n        continue;\n      }\n\n      // If the table has a descendant with any of these tags, consider a data table:\n      var dataTableDescendants = [\"col\", \"colgroup\", \"tfoot\", \"thead\", \"th\"];\n      var descendantExists = function(tag) {\n        return !!table.getElementsByTagName(tag)[0];\n      };\n      if (dataTableDescendants.some(descendantExists)) {\n        this.log(\"Data table because found data-y descendant\");\n        table._readabilityDataTable = true;\n        continue;\n      }\n\n      // Nested tables indicate a layout table:\n      if (table.getElementsByTagName(\"table\")[0]) {\n        table._readabilityDataTable = false;\n        continue;\n      }\n\n      var sizeInfo = this._getRowAndColumnCount(table);\n      if (sizeInfo.rows >= 10 || sizeInfo.columns > 4) {\n        table._readabilityDataTable = true;\n        continue;\n      }\n      // Now just go by size entirely:\n      table._readabilityDataTable = sizeInfo.rows * sizeInfo.columns > 10;\n    }\n  },\n\n  /* convert images and figures that have properties like data-src into images that can be loaded without JS */\n  _fixLazyImages: function (root) {\n    this._forEachNode(this._getAllNodesWithTag(root, [\"img\", \"picture\", \"figure\"]), function (elem) {\n      // In some sites (e.g. Kotaku), they put 1px square image as base64 data uri in the src attribute.\n      // So, here we check if the data uri is too short, just might as well remove it.\n      if (elem.src && this.REGEXPS.b64DataUrl.test(elem.src)) {\n        // Make sure it's not SVG, because SVG can have a meaningful image in under 133 bytes.\n        var parts = this.REGEXPS.b64DataUrl.exec(elem.src);\n        if (parts[1] === \"image/svg+xml\") {\n          return;\n        }\n\n        // Make sure this element has other attributes which contains image.\n        // If it doesn't, then this src is important and shouldn't be removed.\n        var srcCouldBeRemoved = false;\n        for (var i = 0; i < elem.attributes.length; i++) {\n          var attr = elem.attributes[i];\n          if (attr.name === \"src\") {\n            continue;\n          }\n\n          if (/\\.(jpg|jpeg|png|webp)/i.test(attr.value)) {\n            srcCouldBeRemoved = true;\n            break;\n          }\n        }\n\n        // Here we assume if image is less than 100 bytes (or 133B after encoded to base64)\n        // it will be too small, therefore it might be placeholder image.\n        if (srcCouldBeRemoved) {\n          var b64starts = elem.src.search(/base64\\s*/i) + 7;\n          var b64length = elem.src.length - b64starts;\n          if (b64length < 133) {\n            elem.removeAttribute(\"src\");\n          }\n        }\n      }\n\n      // also check for \"null\" to work around https://github.com/jsdom/jsdom/issues/2580\n      if ((elem.src || (elem.srcset && elem.srcset != \"null\")) && elem.className.toLowerCase().indexOf(\"lazy\") === -1) {\n        return;\n      }\n\n      for (var j = 0; j < elem.attributes.length; j++) {\n        attr = elem.attributes[j];\n        if (attr.name === \"src\" || attr.name === \"srcset\" || attr.name === \"alt\") {\n          continue;\n        }\n        var copyTo = null;\n        if (/\\.(jpg|jpeg|png|webp)\\s+\\d/.test(attr.value)) {\n          copyTo = \"srcset\";\n        } else if (/^\\s*\\S+\\.(jpg|jpeg|png|webp)\\S*\\s*$/.test(attr.value)) {\n          copyTo = \"src\";\n        }\n        if (copyTo) {\n          //if this is an img or picture, set the attribute directly\n          if (elem.tagName === \"IMG\" || elem.tagName === \"PICTURE\") {\n            elem.setAttribute(copyTo, attr.value);\n          } else if (elem.tagName === \"FIGURE\" && !this._getAllNodesWithTag(elem, [\"img\", \"picture\"]).length) {\n            //if the item is a <figure> that does not contain an image or picture, create one and place it inside the figure\n            //see the nytimes-3 testcase for an example\n            var img = this._doc.createElement(\"img\");\n            img.setAttribute(copyTo, attr.value);\n            elem.appendChild(img);\n          }\n        }\n      }\n    });\n  },\n\n  _getTextDensity: function(e, tags) {\n    var textLength = this._getInnerText(e, true).length;\n    if (textLength === 0) {\n      return 0;\n    }\n    var childrenLength = 0;\n    var children = this._getAllNodesWithTag(e, tags);\n    this._forEachNode(children, (child) => childrenLength += this._getInnerText(child, true).length);\n    return childrenLength / textLength;\n  },\n\n  /**\n   * Clean an element of all tags of type \"tag\" if they look fishy.\n   * \"Fishy\" is an algorithm based on content length, classnames, link density, number of images & embeds, etc.\n   *\n   * @return void\n   **/\n  _cleanConditionally: function(e, tag) {\n    if (!this._flagIsActive(this.FLAG_CLEAN_CONDITIONALLY))\n      return;\n\n    // Gather counts for other typical elements embedded within.\n    // Traverse backwards so we can remove nodes at the same time\n    // without effecting the traversal.\n    //\n    // TODO: Consider taking into account original contentScore here.\n    this._removeNodes(this._getAllNodesWithTag(e, [tag]), function(node) {\n      // First check if this node IS data table, in which case don't remove it.\n      var isDataTable = function(t) {\n        return t._readabilityDataTable;\n      };\n\n      var isList = tag === \"ul\" || tag === \"ol\";\n      if (!isList) {\n        var listLength = 0;\n        var listNodes = this._getAllNodesWithTag(node, [\"ul\", \"ol\"]);\n        this._forEachNode(listNodes, (list) => listLength += this._getInnerText(list).length);\n        isList = listLength / this._getInnerText(node).length > 0.9;\n      }\n\n      if (tag === \"table\" && isDataTable(node)) {\n        return false;\n      }\n\n      // Next check if we're inside a data table, in which case don't remove it as well.\n      if (this._hasAncestorTag(node, \"table\", -1, isDataTable)) {\n        return false;\n      }\n\n      if (this._hasAncestorTag(node, \"code\")) {\n        return false;\n      }\n\n      var weight = this._getClassWeight(node);\n\n      this.log(\"Cleaning Conditionally\", node);\n\n      var contentScore = 0;\n\n      if (weight + contentScore < 0) {\n        return true;\n      }\n\n      if (this._getCharCount(node, \",\") < 10) {\n        // If there are not very many commas, and the number of\n        // non-paragraph elements is more than paragraphs or other\n        // ominous signs, remove the element.\n        var p = node.getElementsByTagName(\"p\").length;\n        var img = node.getElementsByTagName(\"img\").length;\n        var li = node.getElementsByTagName(\"li\").length - 100;\n        var input = node.getElementsByTagName(\"input\").length;\n        var headingDensity = this._getTextDensity(node, [\"h1\", \"h2\", \"h3\", \"h4\", \"h5\", \"h6\"]);\n\n        var embedCount = 0;\n        var embeds = this._getAllNodesWithTag(node, [\"object\", \"embed\", \"iframe\"]);\n\n        for (var i = 0; i < embeds.length; i++) {\n          // If this embed has attribute that matches video regex, don't delete it.\n          for (var j = 0; j < embeds[i].attributes.length; j++) {\n            if (this._allowedVideoRegex.test(embeds[i].attributes[j].value)) {\n              return false;\n            }\n          }\n\n          // For embed with <object> tag, check inner HTML as well.\n          if (embeds[i].tagName === \"object\" && this._allowedVideoRegex.test(embeds[i].innerHTML)) {\n            return false;\n          }\n\n          embedCount++;\n        }\n\n        var linkDensity = this._getLinkDensity(node);\n        var contentLength = this._getInnerText(node).length;\n\n        var haveToRemove =\n          (img > 1 && p / img < 0.5 && !this._hasAncestorTag(node, \"figure\")) ||\n          (!isList && li > p) ||\n          (input > Math.floor(p/3)) ||\n          (!isList && headingDensity < 0.9 && contentLength < 25 && (img === 0 || img > 2) && !this._hasAncestorTag(node, \"figure\")) ||\n          (!isList && weight < 25 && linkDensity > 0.2) ||\n          (weight >= 25 && linkDensity > 0.5) ||\n          ((embedCount === 1 && contentLength < 75) || embedCount > 1);\n        // Allow simple lists of images to remain in pages\n        if (isList && haveToRemove) {\n          for (var x = 0; x < node.children.length; x++) {\n            let child = node.children[x];\n            // Don't filter in lists with li's that contain more than one child\n            if (child.children.length > 1) {\n              return haveToRemove;\n            }\n          }\n          let li_count = node.getElementsByTagName(\"li\").length;\n          // Only allow the list to remain if every li contains an image\n          if (img == li_count) {\n            return false;\n          }\n        }\n        return haveToRemove;\n      }\n      return false;\n    });\n  },\n\n  /**\n   * Clean out elements that match the specified conditions\n   *\n   * @param Element\n   * @param Function determines whether a node should be removed\n   * @return void\n   **/\n  _cleanMatchedNodes: function(e, filter) {\n    var endOfSearchMarkerNode = this._getNextNode(e, true);\n    var next = this._getNextNode(e);\n    while (next && next != endOfSearchMarkerNode) {\n      if (filter.call(this, next, next.className + \" \" + next.id)) {\n        next = this._removeAndGetNext(next);\n      } else {\n        next = this._getNextNode(next);\n      }\n    }\n  },\n\n  /**\n   * Clean out spurious headers from an Element.\n   *\n   * @param Element\n   * @return void\n  **/\n  _cleanHeaders: function(e) {\n    let headingNodes = this._getAllNodesWithTag(e, [\"h1\", \"h2\"]);\n    this._removeNodes(headingNodes, function(node) {\n      let shouldRemove = this._getClassWeight(node) < 0;\n      if (shouldRemove) {\n        this.log(\"Removing header with low class weight:\", node);\n      }\n      return shouldRemove;\n    });\n  },\n\n  /**\n   * Check if this node is an H1 or H2 element whose content is mostly\n   * the same as the article title.\n   *\n   * @param Element  the node to check.\n   * @return boolean indicating whether this is a title-like header.\n   */\n  _headerDuplicatesTitle: function(node) {\n    if (node.tagName != \"H1\" && node.tagName != \"H2\") {\n      return false;\n    }\n    var heading = this._getInnerText(node, false);\n    this.log(\"Evaluating similarity of header:\", heading, this._articleTitle);\n    return this._textSimilarity(this._articleTitle, heading) > 0.75;\n  },\n\n  _flagIsActive: function(flag) {\n    return (this._flags & flag) > 0;\n  },\n\n  _removeFlag: function(flag) {\n    this._flags = this._flags & ~flag;\n  },\n\n  _isProbablyVisible: function(node) {\n    // Have to null-check node.style and node.className.indexOf to deal with SVG and MathML nodes.\n    return (!node.style || node.style.display != \"none\")\n      && (!node.style || node.style.visibility != \"hidden\")\n      && !node.hasAttribute(\"hidden\")\n      //check for \"fallback-image\" so that wikimedia math images are displayed\n      && (!node.hasAttribute(\"aria-hidden\") || node.getAttribute(\"aria-hidden\") != \"true\" || (node.className && node.className.indexOf && node.className.indexOf(\"fallback-image\") !== -1));\n  },\n\n  /**\n   * Runs readability.\n   *\n   * Workflow:\n   *  1. Prep the document by removing script tags, css, etc.\n   *  2. Build readability's DOM tree.\n   *  3. Grab the article content from the current dom tree.\n   *  4. Replace the current DOM tree with the new one.\n   *  5. Read peacefully.\n   *\n   * @return void\n   **/\n  parse: function () {\n    // Avoid parsing too large documents, as per configuration option\n    if (this._maxElemsToParse > 0) {\n      var numTags = this._doc.getElementsByTagName(\"*\").length;\n      if (numTags > this._maxElemsToParse) {\n        throw new Error(\"Aborting parsing document; \" + numTags + \" elements found\");\n      }\n    }\n\n    // Unwrap image from noscript\n    this._unwrapNoscriptImages(this._doc);\n\n    // Extract JSON-LD metadata before removing scripts\n    var jsonLd = this._disableJSONLD ? {} : this._getJSONLD(this._doc);\n\n    // Remove script tags from the document.\n    this._removeScripts(this._doc);\n\n    this._prepDocument();\n\n    var metadata = this._getArticleMetadata(jsonLd);\n    this._articleTitle = metadata.title;\n\n    var articleContent = this._grabArticle();\n    if (!articleContent)\n      return null;\n\n    this.log(\"Grabbed: \" + articleContent.innerHTML);\n\n    this._postProcessContent(articleContent);\n\n    // If we haven't found an excerpt in the article's metadata, use the article's\n    // first paragraph as the excerpt. This is used for displaying a preview of\n    // the article's content.\n    if (!metadata.excerpt) {\n      var paragraphs = articleContent.getElementsByTagName(\"p\");\n      if (paragraphs.length > 0) {\n        metadata.excerpt = paragraphs[0].textContent.trim();\n      }\n    }\n\n    var textContent = articleContent.textContent;\n    return {\n      title: this._articleTitle,\n      byline: metadata.byline || this._articleByline,\n      dir: this._articleDir,\n      lang: this._articleLang,\n      content: this._serializer(articleContent),\n      textContent: textContent,\n      length: textContent.length,\n      excerpt: metadata.excerpt,\n      siteName: metadata.siteName || this._articleSiteName,\n      publishedTime: metadata.publishedTime\n    };\n  }\n};\n\nif (typeof module === \"object\") {\n  /* global module */\n  module.exports = Readability;\n}\n", "/*\n * Copyright (c) 2010 Arc90 Inc\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\n/*\n * This code is heavily based on Arc90's readability.js (1.7.1) script\n * available at: http://code.google.com/p/arc90labs-readability\n */\n\nvar REGEXPS = {\n  // NOTE: These two regular expressions are duplicated in\n  // Readability.js. Please keep both copies in sync.\n  unlikelyCandidates: /-ad-|ai2html|banner|breadcrumbs|combx|comment|community|cover-wrap|disqus|extra|footer|gdpr|header|legends|menu|related|remark|replies|rss|shoutbox|sidebar|skyscraper|social|sponsor|supplemental|ad-break|agegate|pagination|pager|popup|yom-remote/i,\n  okMaybeItsACandidate: /and|article|body|column|content|main|shadow/i,\n};\n\nfunction isNodeVisible(node) {\n  // Have to null-check node.style and node.className.indexOf to deal with SVG and MathML nodes.\n  return (!node.style || node.style.display != \"none\")\n    && !node.hasAttribute(\"hidden\")\n    //check for \"fallback-image\" so that wikimedia math images are displayed\n    && (!node.hasAttribute(\"aria-hidden\") || node.getAttribute(\"aria-hidden\") != \"true\" || (node.className && node.className.indexOf && node.className.indexOf(\"fallback-image\") !== -1));\n}\n\n/**\n * Decides whether or not the document is reader-able without parsing the whole thing.\n * @param {Object} options Configuration object.\n * @param {number} [options.minContentLength=140] The minimum node content length used to decide if the document is readerable.\n * @param {number} [options.minScore=20] The minumum cumulated 'score' used to determine if the document is readerable.\n * @param {Function} [options.visibilityChecker=isNodeVisible] The function used to determine if a node is visible.\n * @return {boolean} Whether or not we suspect Readability.parse() will suceeed at returning an article object.\n */\nfunction isProbablyReaderable(doc, options = {}) {\n  // For backward compatibility reasons 'options' can either be a configuration object or the function used\n  // to determine if a node is visible.\n  if (typeof options == \"function\") {\n    options = { visibilityChecker: options };\n  }\n\n  var defaultOptions = { minScore: 20, minContentLength: 140, visibilityChecker: isNodeVisible };\n  options = Object.assign(defaultOptions, options);\n\n  var nodes = doc.querySelectorAll(\"p, pre, article\");\n\n  // Get <div> nodes which have <br> node(s) and append them into the `nodes` variable.\n  // Some articles' DOM structures might look like\n  // <div>\n  //   Sentences<br>\n  //   <br>\n  //   Sentences<br>\n  // </div>\n  var brNodes = doc.querySelectorAll(\"div > br\");\n  if (brNodes.length) {\n    var set = new Set(nodes);\n    [].forEach.call(brNodes, function (node) {\n      set.add(node.parentNode);\n    });\n    nodes = Array.from(set);\n  }\n\n  var score = 0;\n  // This is a little cheeky, we use the accumulator 'score' to decide what to return from\n  // this callback:\n  return [].some.call(nodes, function (node) {\n    if (!options.visibilityChecker(node)) {\n      return false;\n    }\n\n    var matchString = node.className + \" \" + node.id;\n    if (REGEXPS.unlikelyCandidates.test(matchString) &&\n        !REGEXPS.okMaybeItsACandidate.test(matchString)) {\n      return false;\n    }\n\n    if (node.matches(\"li p\")) {\n      return false;\n    }\n\n    var textContentLength = node.textContent.trim().length;\n    if (textContentLength < options.minContentLength) {\n      return false;\n    }\n\n    score += Math.sqrt(textContentLength - options.minContentLength);\n\n    if (score > options.minScore) {\n      return true;\n    }\n    return false;\n  });\n}\n\nif (typeof module === \"object\") {\n  /* global module */\n  module.exports = isProbablyReaderable;\n}\n", "/* eslint-env node */\nvar Readability = require(\"./Readability\");\nvar isProbablyReaderable = require(\"./Readability-readerable\");\n\nmodule.exports = {\n  Readability: Readability,\n  isProbablyReaderable: isProbablyReaderable\n};\n", "import { Readability } from \"@mozilla/readability\";\n\nfunction getSource(): string {\n  const meta =\n    document.querySelector(\"meta[property='og:site_name']\") ||\n    document.querySelector(\"meta[name='application-name']\");\n  return (meta && meta.getAttribute(\"content\")) || window.location.hostname || \"Unknown\";\n}\n\nfunction normalizePublishedDate(raw?: string | null): string | undefined {\n  if (!raw) return undefined;\n  const trimmed = raw.trim();\n\n  const dateMatch = trimmed.match(/(\\d{4}-\\d{2}-\\d{2})/);\n  if (dateMatch) return dateMatch[1];\n\n  const parsed = Date.parse(trimmed);\n  if (Number.isNaN(parsed)) return undefined;\n\n  return new Date(parsed).toISOString().slice(0, 10);\n}\n\nfunction getPublished(): string | undefined {\n  const candidates = [\n    \"meta[property='article:published_time']\",\n    \"meta[name='pubdate']\",\n    \"meta[name='date']\",\n    \"time[datetime]\",\n  ];\n  for (const sel of candidates) {\n    const el = document.querySelector(sel);\n    const val = el?.getAttribute(\"content\") || el?.getAttribute(\"datetime\") || el?.textContent;\n    const normalized = normalizePublishedDate(val);\n    if (normalized) return normalized;\n  }\n  return undefined;\n}\n\nfunction getContent(): string | undefined {\n  try {\n    const clone = document.cloneNode(true) as Document;\n    const article = new Readability(clone).parse();\n    return article?.textContent || undefined;\n  } catch {\n    return undefined;\n  }\n}\n\nfunction scrapeArticle() {\n  const payload = {\n    title: document.title || \"\",\n    source: getSource(),\n    url: window.location.href,\n    published_at: getPublished(),\n    content: getContent(),\n  };\n\n  chrome.runtime.sendMessage({ type: \"ARTICLE_SCRAPED\", payload });\n}\n\nscrapeArticle();\n"],
  "mappings": "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",
  "names": ["Readability", "ancestors", "Readability"]
}
